# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def deconstruct(); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end

  def github(); end

  def ref(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::Dsl
  def check_primary_source_safety(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::RemoteSpecification
  def required_rubygems_version(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def missing_specs(); end
end

class Bundler::StubSpecification
  def default_gem?(); end

  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(_); end
end

class Dry::Inflector
  DEFAULT_SEPARATOR = ::T.let(nil, ::T.untyped)
  ORDINALIZE_TH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def initialize(*_); end
end

class File
  def self.absolute_path?(_); end

  def self.exists?(_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  include ::Gem::Requirement::OrderIndependentComparison
  include ::Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::CorrectHashForLambdaOperator
  def hash(); end
end

module Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::OrderIndependentComparison
  def ==(other); end

  def _requirements_sorted?(); end

  def _with_sorted_requirements(); end
end

module Gem::Requirement::OrderIndependentComparison
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def deleted_gem?(); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(_); end
end

class Hash
  def self.ruby2_keywords_hash(_); end

  def self.ruby2_keywords_hash?(_); end

  def self.try_convert(_); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(); end

  def self.colorable?(); end

  def self.colorize(text, seq); end

  def self.colorize_code(code, complete: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def omit_on_assignment(); end

  def omit_on_assignment=(omit_on_assignment); end

  def omit_on_assignment?(); end

  def use_colorize(); end

  def use_colorize?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reidline(); end

  def use_reidline?(); end

  def use_singleline(); end

  def use_singleline?(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_info(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end

  def winsize(); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def prompt(prompt, ltype, indent, line_no); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::ReidlineInputMethod
  include ::Reline
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReidlineInputMethod
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module KubeDSL
  KUBERNETES_VERSION = ::T.let(nil, ::T.untyped)
end

class KubeDSL::ArrayFieldRes
  include ::KubeDSL::StringHelpers
  def elem_res(); end

  def fields_to_ruby(inflector); end

  def initialize(name, required, elem_res); end

  def name(); end

  def required(); end

  def required?(); end

  def serialize_call(inflector); end

  def validations(inflector); end
end

class KubeDSL::ArrayFieldRes
end

class KubeDSL::Builder
  include ::KubeDSL::StringHelpers
  def autoload_prefix(); end

  def dsl_namespace(); end

  def each_autoload_file(&block); end

  def each_resource_file(); end

  def entrypoint(&block); end

  def entrypoint_namespace(); end

  def entrypoint_path(); end

  def inflector(); end

  def initialize(schema_dir:, output_dir:, autoload_prefix:, inflector:, dsl_namespace:, entrypoint_namespace:); end

  def output_dir(); end

  def parse_ref(ref_str); end

  def register_resolver(*prefixes, &resolver); end

  def resolvers(); end

  def resource_from_ref(ref); end

  def schema_dir(); end
end

class KubeDSL::Builder
end

module KubeDSL::DSL::Admissionregistration
end

module KubeDSL::DSL::Admissionregistration::V1
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhook
  def admission_review_versions(*args); end

  def client_config(*args, &block); end

  def failure_policy(*args); end

  def kind_sym(); end

  def match_policy(*args); end

  def name(*args); end

  def namespace_selector(*args, &block); end

  def object_selector(*args, &block); end

  def reinvocation_policy(*args); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def side_effects(*args); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhook
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfiguration
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def webhook(elem_name=T.unsafe(nil), &block); end

  def webhooks(); end
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfiguration
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfigurationList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1::MutatingWebhookConfigurationList
end

class KubeDSL::DSL::Admissionregistration::V1::RuleWithOperations
  def api_groups(*args); end

  def api_versions(*args); end

  def kind_sym(); end

  def operations(*args); end

  def resources(*args); end

  def scope(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1::RuleWithOperations
end

class KubeDSL::DSL::Admissionregistration::V1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def path(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1::ServiceReference
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhook
  def admission_review_versions(*args); end

  def client_config(*args, &block); end

  def failure_policy(*args); end

  def kind_sym(); end

  def match_policy(*args); end

  def name(*args); end

  def namespace_selector(*args, &block); end

  def object_selector(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def side_effects(*args); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhook
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfiguration
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def webhook(elem_name=T.unsafe(nil), &block); end

  def webhooks(); end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfiguration
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfigurationList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1::ValidatingWebhookConfigurationList
end

class KubeDSL::DSL::Admissionregistration::V1::WebhookClientConfig
  def ca_bundle(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def url(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1::WebhookClientConfig
end

module KubeDSL::DSL::Admissionregistration::V1
end

module KubeDSL::DSL::Admissionregistration::V1beta1
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhook
  def admission_review_versions(*args); end

  def client_config(*args, &block); end

  def failure_policy(*args); end

  def kind_sym(); end

  def match_policy(*args); end

  def name(*args); end

  def namespace_selector(*args, &block); end

  def object_selector(*args, &block); end

  def reinvocation_policy(*args); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def side_effects(*args); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhook
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhookConfiguration
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def webhook(elem_name=T.unsafe(nil), &block); end

  def webhooks(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhookConfiguration
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhookConfigurationList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::MutatingWebhookConfigurationList
end

class KubeDSL::DSL::Admissionregistration::V1beta1::RuleWithOperations
  def api_groups(*args); end

  def api_versions(*args); end

  def kind_sym(); end

  def operations(*args); end

  def resources(*args); end

  def scope(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::RuleWithOperations
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def path(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ServiceReference
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhook
  def admission_review_versions(*args); end

  def client_config(*args, &block); end

  def failure_policy(*args); end

  def kind_sym(); end

  def match_policy(*args); end

  def name(*args); end

  def namespace_selector(*args, &block); end

  def object_selector(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def side_effects(*args); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhook
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhookConfiguration
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def webhook(elem_name=T.unsafe(nil), &block); end

  def webhooks(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhookConfiguration
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhookConfigurationList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::ValidatingWebhookConfigurationList
end

class KubeDSL::DSL::Admissionregistration::V1beta1::WebhookClientConfig
  def ca_bundle(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def url(*args); end
end

class KubeDSL::DSL::Admissionregistration::V1beta1::WebhookClientConfig
end

module KubeDSL::DSL::Admissionregistration::V1beta1
end

module KubeDSL::DSL::Admissionregistration
end

module KubeDSL::DSL::Apiextensions
end

module KubeDSL::DSL::Apiextensions::V1
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceColumnDefinition
  def description(*args); end

  def format(*args); end

  def json_path(*args); end

  def kind_sym(); end

  def name(*args); end

  def priority(*args); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceColumnDefinition
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceConversion
  def kind_sym(); end

  def serialize(); end

  def strategy(*args); end

  def webhook(*args, &block); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceConversion
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionCondition
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionNames
  def categories(*args); end

  def kind(*args); end

  def kind_sym(); end

  def list_kind(*args); end

  def plural(*args); end

  def serialize(); end

  def short_names(*args); end

  def singular(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionNames
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionStatus
  def accepted_names(*args, &block); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end

  def stored_versions(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceDefinitionStatus
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresourceScale
  def kind_sym(); end

  def label_selector_path(*args); end

  def serialize(); end

  def spec_replicas_path(*args); end

  def status_replicas_path(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresourceScale
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresources
  def kind_sym(); end

  def scale(*args, &block); end

  def serialize(); end

  def status(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::CustomResourceSubresources
end

class KubeDSL::DSL::Apiextensions::V1::ExternalDocumentation
  def description(*args); end

  def kind_sym(); end

  def serialize(); end

  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::ExternalDocumentation
end

class KubeDSL::DSL::Apiextensions::V1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def path(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apiextensions::V1::ServiceReference
end

class KubeDSL::DSL::Apiextensions::V1::WebhookClientConfig
  def ca_bundle(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1::WebhookClientConfig
end

class KubeDSL::DSL::Apiextensions::V1::WebhookConversion
  def client_config(*args, &block); end

  def conversion_review_versions(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Apiextensions::V1::WebhookConversion
end

module KubeDSL::DSL::Apiextensions::V1
end

module KubeDSL::DSL::Apiextensions::V1beta1
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceColumnDefinition
  def description(*args); end

  def format(*args); end

  def json_path(*args); end

  def kind_sym(); end

  def name(*args); end

  def priority(*args); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceColumnDefinition
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceConversion
  def conversion_review_versions(*args); end

  def kind_sym(); end

  def serialize(); end

  def strategy(*args); end

  def webhook_client_config(*args, &block); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceConversion
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionCondition
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionNames
  def categories(*args); end

  def kind(*args); end

  def kind_sym(); end

  def list_kind(*args); end

  def plural(*args); end

  def serialize(); end

  def short_names(*args); end

  def singular(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionNames
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionStatus
  def accepted_names(*args, &block); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end

  def stored_versions(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceDefinitionStatus
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceSubresourceScale
  def kind_sym(); end

  def label_selector_path(*args); end

  def serialize(); end

  def spec_replicas_path(*args); end

  def status_replicas_path(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceSubresourceScale
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceSubresources
  def kind_sym(); end

  def scale(*args, &block); end

  def serialize(); end

  def status(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::CustomResourceSubresources
end

class KubeDSL::DSL::Apiextensions::V1beta1::ExternalDocumentation
  def description(*args); end

  def kind_sym(); end

  def serialize(); end

  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::ExternalDocumentation
end

class KubeDSL::DSL::Apiextensions::V1beta1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def path(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::ServiceReference
end

class KubeDSL::DSL::Apiextensions::V1beta1::WebhookClientConfig
  def ca_bundle(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def url(*args); end
end

class KubeDSL::DSL::Apiextensions::V1beta1::WebhookClientConfig
end

module KubeDSL::DSL::Apiextensions::V1beta1
end

module KubeDSL::DSL::Apiextensions
end

module KubeDSL::DSL::Apiregistration
end

module KubeDSL::DSL::Apiregistration::V1
end

class KubeDSL::DSL::Apiregistration::V1::APIService
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apiregistration::V1::APIService
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceCondition
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceList
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceSpec
  def ca_bundle(*args); end

  def group(*args); end

  def group_priority_minimum(*args); end

  def insecure_skip_tls_verify(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def version(*args); end

  def version_priority(*args); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceSpec
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1::APIServiceStatus
end

class KubeDSL::DSL::Apiregistration::V1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1::ServiceReference
end

module KubeDSL::DSL::Apiregistration::V1
end

module KubeDSL::DSL::Apiregistration::V1beta1
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIService
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIService
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceCondition
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceList
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceSpec
  def ca_bundle(*args); end

  def group(*args); end

  def group_priority_minimum(*args); end

  def insecure_skip_tls_verify(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def version(*args); end

  def version_priority(*args); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceSpec
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::APIServiceStatus
end

class KubeDSL::DSL::Apiregistration::V1beta1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apiregistration::V1beta1::ServiceReference
end

module KubeDSL::DSL::Apiregistration::V1beta1
end

module KubeDSL::DSL::Apiregistration
end

module KubeDSL::DSL::Apps
end

module KubeDSL::DSL::Apps::V1
end

class KubeDSL::DSL::Apps::V1::ControllerRevision
  def data(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::ControllerRevision
end

class KubeDSL::DSL::Apps::V1::ControllerRevisionList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::ControllerRevisionList
end

class KubeDSL::DSL::Apps::V1::DaemonSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::DaemonSet
end

class KubeDSL::DSL::Apps::V1::DaemonSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetCondition
end

class KubeDSL::DSL::Apps::V1::DaemonSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetList
end

class KubeDSL::DSL::Apps::V1::DaemonSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end

  def update_strategy(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetSpec
end

class KubeDSL::DSL::Apps::V1::DaemonSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_number_scheduled(*args); end

  def desired_number_scheduled(*args); end

  def kind_sym(); end

  def number_available(*args); end

  def number_misscheduled(*args); end

  def number_ready(*args); end

  def number_unavailable(*args); end

  def observed_generation(*args); end

  def serialize(); end

  def updated_number_scheduled(*args); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetStatus
end

class KubeDSL::DSL::Apps::V1::DaemonSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DaemonSetUpdateStrategy
end

class KubeDSL::DSL::Apps::V1::Deployment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::Deployment
end

class KubeDSL::DSL::Apps::V1::DeploymentCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def last_update_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DeploymentCondition
end

class KubeDSL::DSL::Apps::V1::DeploymentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::DeploymentList
end

class KubeDSL::DSL::Apps::V1::DeploymentSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def paused(*args); end

  def progress_deadline_seconds(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def strategy(*args, &block); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::DeploymentSpec
end

class KubeDSL::DSL::Apps::V1::DeploymentStatus
  def available_replicas(*args); end

  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def unavailable_replicas(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1::DeploymentStatus
end

class KubeDSL::DSL::Apps::V1::DeploymentStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::DeploymentStrategy
end

class KubeDSL::DSL::Apps::V1::ReplicaSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSet
end

class KubeDSL::DSL::Apps::V1::ReplicaSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetCondition
end

class KubeDSL::DSL::Apps::V1::ReplicaSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetList
end

class KubeDSL::DSL::Apps::V1::ReplicaSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetSpec
end

class KubeDSL::DSL::Apps::V1::ReplicaSetStatus
  def available_replicas(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def fully_labeled_replicas(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::ReplicaSetStatus
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDaemonSet
  def kind_sym(); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDaemonSet
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDeployment
  def kind_sym(); end

  def max_surge(*args); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateDeployment
end

class KubeDSL::DSL::Apps::V1::RollingUpdateStatefulSetStrategy
  def kind_sym(); end

  def partition(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::RollingUpdateStatefulSetStrategy
end

class KubeDSL::DSL::Apps::V1::StatefulSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1::StatefulSet
end

class KubeDSL::DSL::Apps::V1::StatefulSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetCondition
end

class KubeDSL::DSL::Apps::V1::StatefulSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetList
end

class KubeDSL::DSL::Apps::V1::StatefulSetSpec
  def kind_sym(); end

  def pod_management_policy(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def service_name(*args); end

  def template(*args, &block); end

  def update_strategy(*args, &block); end

  def volume_claim_template(elem_name=T.unsafe(nil), &block); end

  def volume_claim_templates(); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetSpec
end

class KubeDSL::DSL::Apps::V1::StatefulSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_replicas(*args); end

  def current_revision(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def update_revision(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetStatus
end

class KubeDSL::DSL::Apps::V1::StatefulSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1::StatefulSetUpdateStrategy
end

module KubeDSL::DSL::Apps::V1
end

module KubeDSL::DSL::Apps::V1beta1
end

class KubeDSL::DSL::Apps::V1beta1::ControllerRevision
  def data(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::ControllerRevision
end

class KubeDSL::DSL::Apps::V1beta1::ControllerRevisionList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::ControllerRevisionList
end

class KubeDSL::DSL::Apps::V1beta1::Deployment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta1::Deployment
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def last_update_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentCondition
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentList
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentRollback
  def kind_sym(); end

  def name(*args); end

  def rollback_to(*args, &block); end

  def serialize(); end

  def updated_annotations(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentRollback
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def paused(*args); end

  def progress_deadline_seconds(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def rollback_to(*args, &block); end

  def selector(*args, &block); end

  def serialize(); end

  def strategy(*args, &block); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentSpec
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentStatus
  def available_replicas(*args); end

  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def unavailable_replicas(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentStatus
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::DeploymentStrategy
end

class KubeDSL::DSL::Apps::V1beta1::RollbackConfig
  def kind_sym(); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::RollbackConfig
end

class KubeDSL::DSL::Apps::V1beta1::RollingUpdateDeployment
  def kind_sym(); end

  def max_surge(*args); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::RollingUpdateDeployment
end

class KubeDSL::DSL::Apps::V1beta1::RollingUpdateStatefulSetStrategy
  def kind_sym(); end

  def partition(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::RollingUpdateStatefulSetStrategy
end

class KubeDSL::DSL::Apps::V1beta1::Scale
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta1::Scale
end

class KubeDSL::DSL::Apps::V1beta1::ScaleSpec
  def kind_sym(); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::ScaleSpec
end

class KubeDSL::DSL::Apps::V1beta1::ScaleStatus
  def kind_sym(); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target_selector(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::ScaleStatus
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSet
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetCondition
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetList
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetSpec
  def kind_sym(); end

  def pod_management_policy(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def service_name(*args); end

  def template(*args, &block); end

  def update_strategy(*args, &block); end

  def volume_claim_template(elem_name=T.unsafe(nil), &block); end

  def volume_claim_templates(); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetSpec
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_replicas(*args); end

  def current_revision(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def update_revision(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetStatus
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta1::StatefulSetUpdateStrategy
end

module KubeDSL::DSL::Apps::V1beta1
end

module KubeDSL::DSL::Apps::V1beta2
end

class KubeDSL::DSL::Apps::V1beta2::ControllerRevision
  def data(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::ControllerRevision
end

class KubeDSL::DSL::Apps::V1beta2::ControllerRevisionList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::ControllerRevisionList
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSet
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetCondition
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetList
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end

  def update_strategy(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetSpec
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_number_scheduled(*args); end

  def desired_number_scheduled(*args); end

  def kind_sym(); end

  def number_available(*args); end

  def number_misscheduled(*args); end

  def number_ready(*args); end

  def number_unavailable(*args); end

  def observed_generation(*args); end

  def serialize(); end

  def updated_number_scheduled(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetStatus
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DaemonSetUpdateStrategy
end

class KubeDSL::DSL::Apps::V1beta2::Deployment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::Deployment
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def last_update_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentCondition
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentList
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def paused(*args); end

  def progress_deadline_seconds(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def strategy(*args, &block); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentSpec
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentStatus
  def available_replicas(*args); end

  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def unavailable_replicas(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentStatus
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::DeploymentStrategy
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSet
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetCondition
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetList
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetSpec
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetStatus
  def available_replicas(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def fully_labeled_replicas(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::ReplicaSetStatus
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateDaemonSet
  def kind_sym(); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateDaemonSet
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateDeployment
  def kind_sym(); end

  def max_surge(*args); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateDeployment
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateStatefulSetStrategy
  def kind_sym(); end

  def partition(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::RollingUpdateStatefulSetStrategy
end

class KubeDSL::DSL::Apps::V1beta2::Scale
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::Scale
end

class KubeDSL::DSL::Apps::V1beta2::ScaleSpec
  def kind_sym(); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::ScaleSpec
end

class KubeDSL::DSL::Apps::V1beta2::ScaleStatus
  def kind_sym(); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target_selector(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::ScaleStatus
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSet
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetCondition
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetList
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetSpec
  def kind_sym(); end

  def pod_management_policy(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def service_name(*args); end

  def template(*args, &block); end

  def update_strategy(*args, &block); end

  def volume_claim_template(elem_name=T.unsafe(nil), &block); end

  def volume_claim_templates(); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetSpec
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_replicas(*args); end

  def current_revision(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def update_revision(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetStatus
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Apps::V1beta2::StatefulSetUpdateStrategy
end

module KubeDSL::DSL::Apps::V1beta2
end

module KubeDSL::DSL::Apps
end

module KubeDSL::DSL::Auditregistration
end

module KubeDSL::DSL::Auditregistration::V1alpha1
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSink
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSink
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSinkList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSinkList
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSinkSpec
  def kind_sym(); end

  def policy(*args, &block); end

  def serialize(); end

  def webhook(*args, &block); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::AuditSinkSpec
end

class KubeDSL::DSL::Auditregistration::V1alpha1::Policy
  def kind_sym(); end

  def level(*args); end

  def serialize(); end

  def stages(*args); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::Policy
end

class KubeDSL::DSL::Auditregistration::V1alpha1::ServiceReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def path(*args); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::ServiceReference
end

class KubeDSL::DSL::Auditregistration::V1alpha1::Webhook
  def client_config(*args, &block); end

  def kind_sym(); end

  def serialize(); end

  def throttle(*args, &block); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::Webhook
end

class KubeDSL::DSL::Auditregistration::V1alpha1::WebhookClientConfig
  def ca_bundle(*args); end

  def kind_sym(); end

  def serialize(); end

  def service(*args, &block); end

  def url(*args); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::WebhookClientConfig
end

class KubeDSL::DSL::Auditregistration::V1alpha1::WebhookThrottleConfig
  def burst(*args); end

  def kind_sym(); end

  def qps(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Auditregistration::V1alpha1::WebhookThrottleConfig
end

module KubeDSL::DSL::Auditregistration::V1alpha1
end

module KubeDSL::DSL::Auditregistration
end

module KubeDSL::DSL::Authentication
end

module KubeDSL::DSL::Authentication::V1
end

class KubeDSL::DSL::Authentication::V1::BoundObjectReference
  def api_version(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::Authentication::V1::BoundObjectReference
end

class KubeDSL::DSL::Authentication::V1::TokenRequest
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authentication::V1::TokenRequest
end

class KubeDSL::DSL::Authentication::V1::TokenRequestSpec
  def audiences(*args); end

  def bound_object_ref(*args, &block); end

  def expiration_seconds(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Authentication::V1::TokenRequestSpec
end

class KubeDSL::DSL::Authentication::V1::TokenRequestStatus
  def expiration_timestamp(*args); end

  def kind_sym(); end

  def serialize(); end

  def token(*args); end
end

class KubeDSL::DSL::Authentication::V1::TokenRequestStatus
end

class KubeDSL::DSL::Authentication::V1::TokenReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authentication::V1::TokenReview
end

class KubeDSL::DSL::Authentication::V1::TokenReviewSpec
  def audiences(*args); end

  def kind_sym(); end

  def serialize(); end

  def token(*args); end
end

class KubeDSL::DSL::Authentication::V1::TokenReviewSpec
end

class KubeDSL::DSL::Authentication::V1::TokenReviewStatus
  def audiences(*args); end

  def authenticated(*args); end

  def error(*args); end

  def kind_sym(); end

  def serialize(); end

  def user(*args, &block); end
end

class KubeDSL::DSL::Authentication::V1::TokenReviewStatus
end

class KubeDSL::DSL::Authentication::V1::UserInfo
  def extra(*args, &block); end

  def groups(*args); end

  def kind_sym(); end

  def serialize(); end

  def uid(*args); end

  def username(*args); end
end

class KubeDSL::DSL::Authentication::V1::UserInfo
end

module KubeDSL::DSL::Authentication::V1
end

module KubeDSL::DSL::Authentication::V1beta1
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReview
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReviewSpec
  def audiences(*args); end

  def kind_sym(); end

  def serialize(); end

  def token(*args); end
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReviewSpec
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReviewStatus
  def audiences(*args); end

  def authenticated(*args); end

  def error(*args); end

  def kind_sym(); end

  def serialize(); end

  def user(*args, &block); end
end

class KubeDSL::DSL::Authentication::V1beta1::TokenReviewStatus
end

class KubeDSL::DSL::Authentication::V1beta1::UserInfo
  def extra(*args, &block); end

  def groups(*args); end

  def kind_sym(); end

  def serialize(); end

  def uid(*args); end

  def username(*args); end
end

class KubeDSL::DSL::Authentication::V1beta1::UserInfo
end

module KubeDSL::DSL::Authentication::V1beta1
end

module KubeDSL::DSL::Authentication
end

module KubeDSL::DSL::Authorization
end

module KubeDSL::DSL::Authorization::V1
end

class KubeDSL::DSL::Authorization::V1::LocalSubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1::LocalSubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1::NonResourceAttributes
  def kind_sym(); end

  def path(*args); end

  def serialize(); end

  def verb(*args); end
end

class KubeDSL::DSL::Authorization::V1::NonResourceAttributes
end

class KubeDSL::DSL::Authorization::V1::NonResourceRule
  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1::NonResourceRule
end

class KubeDSL::DSL::Authorization::V1::ResourceAttributes
  def group(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def resource(*args); end

  def serialize(); end

  def subresource(*args); end

  def verb(*args); end

  def version(*args); end
end

class KubeDSL::DSL::Authorization::V1::ResourceAttributes
end

class KubeDSL::DSL::Authorization::V1::ResourceRule
  def api_groups(*args); end

  def kind_sym(); end

  def resource_names(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1::ResourceRule
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReviewSpec
  def kind_sym(); end

  def non_resource_attributes(*args, &block); end

  def resource_attributes(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectAccessReviewSpec
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReview
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReviewSpec
  def kind_sym(); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1::SelfSubjectRulesReviewSpec
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewSpec
  def extra(*args, &block); end

  def groups(*args); end

  def kind_sym(); end

  def non_resource_attributes(*args, &block); end

  def resource_attributes(*args, &block); end

  def serialize(); end

  def uid(*args); end

  def user(*args); end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewSpec
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewStatus
  def allowed(*args); end

  def denied(*args); end

  def evaluation_error(*args); end

  def kind_sym(); end

  def reason(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1::SubjectAccessReviewStatus
end

class KubeDSL::DSL::Authorization::V1::SubjectRulesReviewStatus
  def evaluation_error(*args); end

  def incomplete(*args); end

  def kind_sym(); end

  def non_resource_rule(elem_name=T.unsafe(nil), &block); end

  def non_resource_rules(); end

  def resource_rule(elem_name=T.unsafe(nil), &block); end

  def resource_rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1::SubjectRulesReviewStatus
end

module KubeDSL::DSL::Authorization::V1
end

module KubeDSL::DSL::Authorization::V1beta1
end

class KubeDSL::DSL::Authorization::V1beta1::LocalSubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1beta1::LocalSubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1beta1::NonResourceAttributes
  def kind_sym(); end

  def path(*args); end

  def serialize(); end

  def verb(*args); end
end

class KubeDSL::DSL::Authorization::V1beta1::NonResourceAttributes
end

class KubeDSL::DSL::Authorization::V1beta1::NonResourceRule
  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1beta1::NonResourceRule
end

class KubeDSL::DSL::Authorization::V1beta1::ResourceAttributes
  def group(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def resource(*args); end

  def serialize(); end

  def subresource(*args); end

  def verb(*args); end

  def version(*args); end
end

class KubeDSL::DSL::Authorization::V1beta1::ResourceAttributes
end

class KubeDSL::DSL::Authorization::V1beta1::ResourceRule
  def api_groups(*args); end

  def kind_sym(); end

  def resource_names(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Authorization::V1beta1::ResourceRule
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectAccessReviewSpec
  def kind_sym(); end

  def non_resource_attributes(*args, &block); end

  def resource_attributes(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectAccessReviewSpec
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectRulesReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectRulesReview
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectRulesReviewSpec
  def kind_sym(); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1beta1::SelfSubjectRulesReviewSpec
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReview
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReview
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReviewSpec
  def extra(*args, &block); end

  def group(*args); end

  def kind_sym(); end

  def non_resource_attributes(*args, &block); end

  def resource_attributes(*args, &block); end

  def serialize(); end

  def uid(*args); end

  def user(*args); end
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReviewSpec
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReviewStatus
  def allowed(*args); end

  def denied(*args); end

  def evaluation_error(*args); end

  def kind_sym(); end

  def reason(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectAccessReviewStatus
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectRulesReviewStatus
  def evaluation_error(*args); end

  def incomplete(*args); end

  def kind_sym(); end

  def non_resource_rule(elem_name=T.unsafe(nil), &block); end

  def non_resource_rules(); end

  def resource_rule(elem_name=T.unsafe(nil), &block); end

  def resource_rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Authorization::V1beta1::SubjectRulesReviewStatus
end

module KubeDSL::DSL::Authorization::V1beta1
end

module KubeDSL::DSL::Authorization
end

module KubeDSL::DSL::Autoscaling
end

module KubeDSL::DSL::Autoscaling::V1
end

class KubeDSL::DSL::Autoscaling::V1::CrossVersionObjectReference
  def api_version(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V1::CrossVersionObjectReference
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscaler
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscaler
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerList
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerSpec
  def kind_sym(); end

  def max_replicas(*args); end

  def min_replicas(*args); end

  def scale_target_ref(*args, &block); end

  def serialize(); end

  def target_cpu_utilization_percentage(*args); end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerSpec
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerStatus
  def current_cpu_utilization_percentage(*args); end

  def current_replicas(*args); end

  def desired_replicas(*args); end

  def kind_sym(); end

  def last_scale_time(*args); end

  def observed_generation(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V1::HorizontalPodAutoscalerStatus
end

class KubeDSL::DSL::Autoscaling::V1::Scale
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V1::Scale
end

class KubeDSL::DSL::Autoscaling::V1::ScaleSpec
  def kind_sym(); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V1::ScaleSpec
end

class KubeDSL::DSL::Autoscaling::V1::ScaleStatus
  def kind_sym(); end

  def replicas(*args); end

  def selector(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V1::ScaleStatus
end

module KubeDSL::DSL::Autoscaling::V1
end

module KubeDSL::DSL::Autoscaling::V2beta1
end

class KubeDSL::DSL::Autoscaling::V2beta1::CrossVersionObjectReference
  def api_version(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::CrossVersionObjectReference
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricSource
  def kind_sym(); end

  def metric_name(*args); end

  def metric_selector(*args, &block); end

  def serialize(); end

  def target_average_value(*args); end

  def target_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricStatus
  def current_average_value(*args); end

  def current_value(*args); end

  def kind_sym(); end

  def metric_name(*args); end

  def metric_selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ExternalMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscaler
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscaler
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerCondition
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerList
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerSpec
  def kind_sym(); end

  def max_replicas(*args); end

  def metric(elem_name=T.unsafe(nil), &block); end

  def metrics(); end

  def min_replicas(*args); end

  def scale_target_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerSpec
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_metric(elem_name=T.unsafe(nil), &block); end

  def current_metrics(); end

  def current_replicas(*args); end

  def desired_replicas(*args); end

  def kind_sym(); end

  def last_scale_time(*args); end

  def observed_generation(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::HorizontalPodAutoscalerStatus
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricSpec
  def external(*args, &block); end

  def kind_sym(); end

  def object(*args, &block); end

  def pods(*args, &block); end

  def resource(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricSpec
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricStatus
  def external(*args, &block); end

  def kind_sym(); end

  def object(*args, &block); end

  def pods(*args, &block); end

  def resource(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::MetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricSource
  def average_value(*args); end

  def kind_sym(); end

  def metric_name(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target(*args, &block); end

  def target_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricStatus
  def average_value(*args); end

  def current_value(*args); end

  def kind_sym(); end

  def metric_name(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ObjectMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricSource
  def kind_sym(); end

  def metric_name(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target_average_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricStatus
  def current_average_value(*args); end

  def kind_sym(); end

  def metric_name(*args); end

  def selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::PodsMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricSource
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def target_average_utilization(*args); end

  def target_average_value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricStatus
  def current_average_utilization(*args); end

  def current_average_value(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta1::ResourceMetricStatus
end

module KubeDSL::DSL::Autoscaling::V2beta1
end

module KubeDSL::DSL::Autoscaling::V2beta2
end

class KubeDSL::DSL::Autoscaling::V2beta2::CrossVersionObjectReference
  def api_version(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::CrossVersionObjectReference
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricSource
  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricStatus
  def current(*args, &block); end

  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ExternalMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscaler
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscaler
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerCondition
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerList
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerSpec
  def kind_sym(); end

  def max_replicas(*args); end

  def metric(elem_name=T.unsafe(nil), &block); end

  def metrics(); end

  def min_replicas(*args); end

  def scale_target_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerSpec
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_metric(elem_name=T.unsafe(nil), &block); end

  def current_metrics(); end

  def current_replicas(*args); end

  def desired_replicas(*args); end

  def kind_sym(); end

  def last_scale_time(*args); end

  def observed_generation(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::HorizontalPodAutoscalerStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricIdentifier
  def kind_sym(); end

  def name(*args); end

  def selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricIdentifier
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricSpec
  def external(*args, &block); end

  def kind_sym(); end

  def object(*args, &block); end

  def pods(*args, &block); end

  def resource(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricSpec
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricStatus
  def external(*args, &block); end

  def kind_sym(); end

  def object(*args, &block); end

  def pods(*args, &block); end

  def resource(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricTarget
  def average_utilization(*args); end

  def average_value(*args); end

  def kind_sym(); end

  def serialize(); end

  def type(*args); end

  def value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricTarget
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricValueStatus
  def average_utilization(*args); end

  def average_value(*args); end

  def kind_sym(); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::MetricValueStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricSource
  def described_object(*args, &block); end

  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricStatus
  def current(*args, &block); end

  def described_object(*args, &block); end

  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ObjectMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricSource
  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricStatus
  def current(*args, &block); end

  def kind_sym(); end

  def metric(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::PodsMetricStatus
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricSource
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricSource
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricStatus
  def current(*args, &block); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Autoscaling::V2beta2::ResourceMetricStatus
end

module KubeDSL::DSL::Autoscaling::V2beta2
end

module KubeDSL::DSL::Autoscaling
end

module KubeDSL::DSL::Batch
end

module KubeDSL::DSL::Batch::V1
end

class KubeDSL::DSL::Batch::V1::Job
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Batch::V1::Job
end

class KubeDSL::DSL::Batch::V1::JobCondition
  def kind_sym(); end

  def last_probe_time(*args); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Batch::V1::JobCondition
end

class KubeDSL::DSL::Batch::V1::JobList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Batch::V1::JobList
end

class KubeDSL::DSL::Batch::V1::JobSpec
  def active_deadline_seconds(*args); end

  def backoff_limit(*args); end

  def completions(*args); end

  def kind_sym(); end

  def manual_selector(*args); end

  def parallelism(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end

  def ttl_seconds_after_finished(*args); end
end

class KubeDSL::DSL::Batch::V1::JobSpec
end

class KubeDSL::DSL::Batch::V1::JobStatus
  def active(*args); end

  def completion_time(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def failed(*args); end

  def kind_sym(); end

  def serialize(); end

  def start_time(*args); end

  def succeeded(*args); end
end

class KubeDSL::DSL::Batch::V1::JobStatus
end

module KubeDSL::DSL::Batch::V1
end

module KubeDSL::DSL::Batch::V1beta1
end

class KubeDSL::DSL::Batch::V1beta1::CronJob
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Batch::V1beta1::CronJob
end

class KubeDSL::DSL::Batch::V1beta1::CronJobList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobList
end

class KubeDSL::DSL::Batch::V1beta1::CronJobSpec
  def concurrency_policy(*args); end

  def failed_jobs_history_limit(*args); end

  def job_template(*args, &block); end

  def kind_sym(); end

  def schedule(*args); end

  def serialize(); end

  def starting_deadline_seconds(*args); end

  def successful_jobs_history_limit(*args); end

  def suspend(*args); end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobSpec
end

class KubeDSL::DSL::Batch::V1beta1::CronJobStatus
  def active(elem_name=T.unsafe(nil), &block); end

  def actives(); end

  def kind_sym(); end

  def last_schedule_time(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Batch::V1beta1::CronJobStatus
end

class KubeDSL::DSL::Batch::V1beta1::JobTemplateSpec
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Batch::V1beta1::JobTemplateSpec
end

module KubeDSL::DSL::Batch::V1beta1
end

module KubeDSL::DSL::Batch::V2alpha1
end

class KubeDSL::DSL::Batch::V2alpha1::CronJob
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Batch::V2alpha1::CronJob
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobList
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobSpec
  def concurrency_policy(*args); end

  def failed_jobs_history_limit(*args); end

  def job_template(*args, &block); end

  def kind_sym(); end

  def schedule(*args); end

  def serialize(); end

  def starting_deadline_seconds(*args); end

  def successful_jobs_history_limit(*args); end

  def suspend(*args); end
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobSpec
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobStatus
  def active(elem_name=T.unsafe(nil), &block); end

  def actives(); end

  def kind_sym(); end

  def last_schedule_time(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Batch::V2alpha1::CronJobStatus
end

class KubeDSL::DSL::Batch::V2alpha1::JobTemplateSpec
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Batch::V2alpha1::JobTemplateSpec
end

module KubeDSL::DSL::Batch::V2alpha1
end

module KubeDSL::DSL::Batch
end

module KubeDSL::DSL::Certificates
end

module KubeDSL::DSL::Certificates::V1beta1
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequest
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequest
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestCondition
  def kind_sym(); end

  def last_update_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestCondition
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestList
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestSpec
  def extra(*args, &block); end

  def groups(*args); end

  def kind_sym(); end

  def request(*args); end

  def serialize(); end

  def uid(*args); end

  def usages(*args); end

  def username(*args); end
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestSpec
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestStatus
  def certificate(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Certificates::V1beta1::CertificateSigningRequestStatus
end

module KubeDSL::DSL::Certificates::V1beta1
end

module KubeDSL::DSL::Certificates
end

module KubeDSL::DSL::Coordination
end

module KubeDSL::DSL::Coordination::V1
end

class KubeDSL::DSL::Coordination::V1::Lease
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Coordination::V1::Lease
end

class KubeDSL::DSL::Coordination::V1::LeaseList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Coordination::V1::LeaseList
end

class KubeDSL::DSL::Coordination::V1::LeaseSpec
  def acquire_time(*args); end

  def holder_identity(*args); end

  def kind_sym(); end

  def lease_duration_seconds(*args); end

  def lease_transitions(*args); end

  def renew_time(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Coordination::V1::LeaseSpec
end

module KubeDSL::DSL::Coordination::V1
end

module KubeDSL::DSL::Coordination::V1beta1
end

class KubeDSL::DSL::Coordination::V1beta1::Lease
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Coordination::V1beta1::Lease
end

class KubeDSL::DSL::Coordination::V1beta1::LeaseList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Coordination::V1beta1::LeaseList
end

class KubeDSL::DSL::Coordination::V1beta1::LeaseSpec
  def acquire_time(*args); end

  def holder_identity(*args); end

  def kind_sym(); end

  def lease_duration_seconds(*args); end

  def lease_transitions(*args); end

  def renew_time(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Coordination::V1beta1::LeaseSpec
end

module KubeDSL::DSL::Coordination::V1beta1
end

module KubeDSL::DSL::Coordination
end

module KubeDSL::DSL::Discovery
end

module KubeDSL::DSL::Discovery::V1beta1
end

class KubeDSL::DSL::Discovery::V1beta1::Endpoint
  def addresses(*args); end

  def conditions(*args, &block); end

  def hostname(*args); end

  def kind_sym(); end

  def serialize(); end

  def target_ref(*args, &block); end

  def topology(*args, &block); end
end

class KubeDSL::DSL::Discovery::V1beta1::Endpoint
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointConditions
  def kind_sym(); end

  def ready(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointConditions
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointPort
  def app_protocol(*args); end

  def kind_sym(); end

  def name(*args); end

  def port(*args); end

  def protocol(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointPort
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSlice
  def address_type(*args); end

  def endpoint(elem_name=T.unsafe(nil), &block); end

  def endpoints(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSlice
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSliceList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Discovery::V1beta1::EndpointSliceList
end

module KubeDSL::DSL::Discovery::V1beta1
end

module KubeDSL::DSL::Discovery
end

module KubeDSL::DSL::Events
end

module KubeDSL::DSL::Events::V1beta1
end

class KubeDSL::DSL::Events::V1beta1::Event
  def action(*args); end

  def deprecated_count(*args); end

  def deprecated_first_timestamp(*args); end

  def deprecated_last_timestamp(*args); end

  def deprecated_source(*args, &block); end

  def event_time(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def note(*args); end

  def reason(*args); end

  def regarding(*args, &block); end

  def related(*args, &block); end

  def reporting_controller(*args); end

  def reporting_instance(*args); end

  def serialize(); end

  def series(*args, &block); end

  def type(*args); end
end

class KubeDSL::DSL::Events::V1beta1::Event
end

class KubeDSL::DSL::Events::V1beta1::EventList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Events::V1beta1::EventList
end

class KubeDSL::DSL::Events::V1beta1::EventSeries
  def count(*args); end

  def kind_sym(); end

  def last_observed_time(*args); end

  def serialize(); end

  def state(*args); end
end

class KubeDSL::DSL::Events::V1beta1::EventSeries
end

module KubeDSL::DSL::Events::V1beta1
end

module KubeDSL::DSL::Events
end

module KubeDSL::DSL::Extensions
end

module KubeDSL::DSL::Extensions::V1beta1
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedCSIDriver
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedCSIDriver
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedFlexVolume
  def driver(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedFlexVolume
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedHostPath
  def kind_sym(); end

  def path_prefix(*args); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::AllowedHostPath
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSet
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetCondition
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetList
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def revision_history_limit(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end

  def template_generation(*args); end

  def update_strategy(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetSpec
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetStatus
  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def current_number_scheduled(*args); end

  def desired_number_scheduled(*args); end

  def kind_sym(); end

  def number_available(*args); end

  def number_misscheduled(*args); end

  def number_ready(*args); end

  def number_unavailable(*args); end

  def observed_generation(*args); end

  def serialize(); end

  def updated_number_scheduled(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetStatus
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetUpdateStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DaemonSetUpdateStrategy
end

class KubeDSL::DSL::Extensions::V1beta1::Deployment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::Deployment
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def last_update_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentCondition
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentList
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentRollback
  def kind_sym(); end

  def name(*args); end

  def rollback_to(*args, &block); end

  def serialize(); end

  def updated_annotations(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentRollback
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def paused(*args); end

  def progress_deadline_seconds(*args); end

  def replicas(*args); end

  def revision_history_limit(*args); end

  def rollback_to(*args, &block); end

  def selector(*args, &block); end

  def serialize(); end

  def strategy(*args, &block); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentSpec
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentStatus
  def available_replicas(*args); end

  def collision_count(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end

  def unavailable_replicas(*args); end

  def updated_replicas(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentStatus
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentStrategy
  def kind_sym(); end

  def rolling_update(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::DeploymentStrategy
end

class KubeDSL::DSL::Extensions::V1beta1::FSGroupStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::FSGroupStrategyOptions
end

class KubeDSL::DSL::Extensions::V1beta1::HTTPIngressPath
  def backend(*args, &block); end

  def kind_sym(); end

  def path(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::HTTPIngressPath
end

class KubeDSL::DSL::Extensions::V1beta1::HTTPIngressRuleValue
  def kind_sym(); end

  def path(elem_name=T.unsafe(nil), &block); end

  def paths(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::HTTPIngressRuleValue
end

class KubeDSL::DSL::Extensions::V1beta1::HostPortRange
  def kind_sym(); end

  def max(*args); end

  def min(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::HostPortRange
end

class KubeDSL::DSL::Extensions::V1beta1::IDRange
  def kind_sym(); end

  def max(*args); end

  def min(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IDRange
end

class KubeDSL::DSL::Extensions::V1beta1::IPBlock
  def cidr(*args); end

  def except(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IPBlock
end

class KubeDSL::DSL::Extensions::V1beta1::Ingress
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::Ingress
end

class KubeDSL::DSL::Extensions::V1beta1::IngressBackend
  def kind_sym(); end

  def serialize(); end

  def service_name(*args); end

  def service_port(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressBackend
end

class KubeDSL::DSL::Extensions::V1beta1::IngressList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressList
end

class KubeDSL::DSL::Extensions::V1beta1::IngressRule
  def host(*args); end

  def http(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressRule
end

class KubeDSL::DSL::Extensions::V1beta1::IngressSpec
  def backend(*args, &block); end

  def kind_sym(); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def tls(elem_name=T.unsafe(nil), &block); end

  def tlses(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressSpec
end

class KubeDSL::DSL::Extensions::V1beta1::IngressStatus
  def kind_sym(); end

  def load_balancer(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressStatus
end

class KubeDSL::DSL::Extensions::V1beta1::IngressTLS
  def hosts(*args); end

  def kind_sym(); end

  def secret_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::IngressTLS
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicy
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicy
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyEgressRule
  def kind_sym(); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end

  def to(elem_name=T.unsafe(nil), &block); end

  def tos(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyEgressRule
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyIngressRule
  def from(elem_name=T.unsafe(nil), &block); end

  def froms(); end

  def kind_sym(); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyIngressRule
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyList
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyPeer
  def ip_block(*args, &block); end

  def kind_sym(); end

  def namespace_selector(*args, &block); end

  def pod_selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyPeer
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyPort
  def kind_sym(); end

  def port(*args); end

  def protocol(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicyPort
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicySpec
  def egress(elem_name=T.unsafe(nil), &block); end

  def egresses(); end

  def ingress(elem_name=T.unsafe(nil), &block); end

  def ingresses(); end

  def kind_sym(); end

  def pod_selector(*args, &block); end

  def policy_types(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::NetworkPolicySpec
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicy
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicy
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicyList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicyList
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicySpec
  def allow_privilege_escalation(*args); end

  def allowed_capabilities(*args); end

  def allowed_csi_driver(elem_name=T.unsafe(nil), &block); end

  def allowed_csi_drivers(); end

  def allowed_flex_volume(elem_name=T.unsafe(nil), &block); end

  def allowed_flex_volumes(); end

  def allowed_host_path(elem_name=T.unsafe(nil), &block); end

  def allowed_host_paths(); end

  def allowed_proc_mount_types(*args); end

  def allowed_unsafe_sysctls(*args); end

  def default_add_capabilities(*args); end

  def default_allow_privilege_escalation(*args); end

  def forbidden_sysctls(*args); end

  def fs_group(*args, &block); end

  def host_ipc(*args); end

  def host_network(*args); end

  def host_pid(*args); end

  def host_port(elem_name=T.unsafe(nil), &block); end

  def host_ports(); end

  def kind_sym(); end

  def privileged(*args); end

  def read_only_root_filesystem(*args); end

  def required_drop_capabilities(*args); end

  def run_as_group(*args, &block); end

  def run_as_user(*args, &block); end

  def runtime_class(*args, &block); end

  def se_linux(*args, &block); end

  def serialize(); end

  def supplemental_groups(*args, &block); end

  def volumes(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::PodSecurityPolicySpec
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSet
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSet
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetCondition
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetList
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetSpec
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetStatus
  def available_replicas(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def fully_labeled_replicas(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::ReplicaSetStatus
end

class KubeDSL::DSL::Extensions::V1beta1::RollbackConfig
  def kind_sym(); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RollbackConfig
end

class KubeDSL::DSL::Extensions::V1beta1::RollingUpdateDaemonSet
  def kind_sym(); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RollingUpdateDaemonSet
end

class KubeDSL::DSL::Extensions::V1beta1::RollingUpdateDeployment
  def kind_sym(); end

  def max_surge(*args); end

  def max_unavailable(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RollingUpdateDeployment
end

class KubeDSL::DSL::Extensions::V1beta1::RunAsGroupStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RunAsGroupStrategyOptions
end

class KubeDSL::DSL::Extensions::V1beta1::RunAsUserStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RunAsUserStrategyOptions
end

class KubeDSL::DSL::Extensions::V1beta1::RuntimeClassStrategyOptions
  def allowed_runtime_class_names(*args); end

  def default_runtime_class_name(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::RuntimeClassStrategyOptions
end

class KubeDSL::DSL::Extensions::V1beta1::SELinuxStrategyOptions
  def kind_sym(); end

  def rule(*args); end

  def se_linux_options(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::SELinuxStrategyOptions
end

class KubeDSL::DSL::Extensions::V1beta1::Scale
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Extensions::V1beta1::Scale
end

class KubeDSL::DSL::Extensions::V1beta1::ScaleSpec
  def kind_sym(); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::ScaleSpec
end

class KubeDSL::DSL::Extensions::V1beta1::ScaleStatus
  def kind_sym(); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def target_selector(*args); end
end

class KubeDSL::DSL::Extensions::V1beta1::ScaleStatus
end

class KubeDSL::DSL::Extensions::V1beta1::SupplementalGroupsStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Extensions::V1beta1::SupplementalGroupsStrategyOptions
end

module KubeDSL::DSL::Extensions::V1beta1
end

module KubeDSL::DSL::Extensions
end

module KubeDSL::DSL::Flowcontrol
end

module KubeDSL::DSL::Flowcontrol::V1alpha1
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowDistinguisherMethod
  def kind_sym(); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowDistinguisherMethod
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchema
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchema
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaCondition
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaList
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaSpec
  def distinguisher_method(*args, &block); end

  def kind_sym(); end

  def matching_precedence(*args); end

  def priority_level_configuration(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaSpec
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::FlowSchemaStatus
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::GroupSubject
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::GroupSubject
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::LimitResponse
  def kind_sym(); end

  def queuing(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::LimitResponse
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::LimitedPriorityLevelConfiguration
  def assured_concurrency_shares(*args); end

  def kind_sym(); end

  def limit_response(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::LimitedPriorityLevelConfiguration
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::NonResourcePolicyRule
  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::NonResourcePolicyRule
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PolicyRulesWithSubjects
  def kind_sym(); end

  def non_resource_rule(elem_name=T.unsafe(nil), &block); end

  def non_resource_rules(); end

  def resource_rule(elem_name=T.unsafe(nil), &block); end

  def resource_rules(); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PolicyRulesWithSubjects
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfiguration
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfiguration
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationCondition
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationList
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationReference
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationReference
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationSpec
  def kind_sym(); end

  def limited(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationSpec
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::PriorityLevelConfigurationStatus
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::QueuingConfiguration
  def hand_size(*args); end

  def kind_sym(); end

  def queue_length_limit(*args); end

  def queues(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::QueuingConfiguration
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::ResourcePolicyRule
  def api_groups(*args); end

  def cluster_scope(*args); end

  def kind_sym(); end

  def namespaces(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::ResourcePolicyRule
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::ServiceAccountSubject
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::ServiceAccountSubject
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::Subject
  def group(*args, &block); end

  def kind(*args); end

  def kind_sym(); end

  def serialize(); end

  def service_account(*args, &block); end

  def user(*args, &block); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::Subject
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::UserSubject
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Flowcontrol::V1alpha1::UserSubject
end

module KubeDSL::DSL::Flowcontrol::V1alpha1
end

module KubeDSL::DSL::Flowcontrol
end

class KubeDSL::DSL::Meta::V1::APIGroup
  def kind_sym(); end

  def name(*args); end

  def preferred_version(*args, &block); end

  def serialize(); end

  def server_address_by_client_cidr(elem_name=T.unsafe(nil), &block); end

  def server_address_by_client_cidrs(); end

  def version(elem_name=T.unsafe(nil), &block); end

  def versions(); end
end

class KubeDSL::DSL::Meta::V1::APIGroup
end

class KubeDSL::DSL::Meta::V1::APIGroupList
  def group(elem_name=T.unsafe(nil), &block); end

  def groups(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::APIGroupList
end

class KubeDSL::DSL::Meta::V1::APIResource
  def categories(*args); end

  def group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespaced(*args); end

  def serialize(); end

  def short_names(*args); end

  def singular_name(*args); end

  def storage_version_hash(*args); end

  def verbs(*args); end

  def version(*args); end
end

class KubeDSL::DSL::Meta::V1::APIResource
end

class KubeDSL::DSL::Meta::V1::APIResourceList
  def group_version(*args); end

  def kind_sym(); end

  def resource(elem_name=T.unsafe(nil), &block); end

  def resources(); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::APIResourceList
end

class KubeDSL::DSL::Meta::V1::APIVersions
  def kind_sym(); end

  def serialize(); end

  def server_address_by_client_cidr(elem_name=T.unsafe(nil), &block); end

  def server_address_by_client_cidrs(); end

  def versions(*args); end
end

class KubeDSL::DSL::Meta::V1::APIVersions
end

class KubeDSL::DSL::Meta::V1::DeleteOptions
  def api_version(*args); end

  def dry_run(*args); end

  def grace_period_seconds(*args); end

  def kind_sym(); end

  def orphan_dependents(*args); end

  def preconditions(*args, &block); end

  def propagation_policy(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::DeleteOptions
end

class KubeDSL::DSL::Meta::V1::GroupVersionForDiscovery
  def group_version(*args); end

  def kind_sym(); end

  def serialize(); end

  def version(*args); end
end

class KubeDSL::DSL::Meta::V1::GroupVersionForDiscovery
end

class KubeDSL::DSL::Meta::V1::LabelSelector
  def kind_sym(); end

  def match_expression(elem_name=T.unsafe(nil), &block); end

  def match_expressions(); end

  def match_labels(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::LabelSelector
end

class KubeDSL::DSL::Meta::V1::LabelSelectorRequirement
  def key(*args); end

  def kind_sym(); end

  def operator(*args); end

  def serialize(); end

  def values(*args); end
end

class KubeDSL::DSL::Meta::V1::LabelSelectorRequirement
end

class KubeDSL::DSL::Meta::V1::ListMeta
  def continue(*args); end

  def kind_sym(); end

  def remaining_item_count(*args); end

  def resource_version(*args); end

  def self_link(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::ListMeta
end

class KubeDSL::DSL::Meta::V1::ManagedFieldsEntry
  def api_version(*args); end

  def fields_type(*args); end

  def fields_v1(*args); end

  def kind_sym(); end

  def manager(*args); end

  def operation(*args); end

  def serialize(); end

  def time(*args); end
end

class KubeDSL::DSL::Meta::V1::ManagedFieldsEntry
end

class KubeDSL::DSL::Meta::V1::ObjectMeta
  def annotations(*args, &block); end

  def cluster_name(*args); end

  def creation_timestamp(*args); end

  def deletion_grace_period_seconds(*args); end

  def deletion_timestamp(*args); end

  def finalizers(*args); end

  def generate_name(*args); end

  def generation(*args); end

  def kind_sym(); end

  def labels(*args, &block); end

  def managed_field(elem_name=T.unsafe(nil), &block); end

  def managed_fields(); end

  def owner_reference(elem_name=T.unsafe(nil), &block); end

  def owner_references(); end

  def resource_version(*args); end

  def self_link(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::OwnerReference
  def api_version(*args); end

  def block_owner_deletion(*args); end

  def controller(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::OwnerReference
end

class KubeDSL::DSL::Meta::V1::Preconditions
  def kind_sym(); end

  def resource_version(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::Preconditions
end

class KubeDSL::DSL::Meta::V1::ServerAddressByClientCIDR
  def client_cidr(*args); end

  def kind_sym(); end

  def serialize(); end

  def server_address(*args); end
end

class KubeDSL::DSL::Meta::V1::ServerAddressByClientCIDR
end

class KubeDSL::DSL::Meta::V1::Status
  def code(*args); end

  def details(*args, &block); end

  def kind_sym(); end

  def message(*args); end

  def metadata(*args, &block); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end
end

class KubeDSL::DSL::Meta::V1::Status
end

class KubeDSL::DSL::Meta::V1::StatusCause
  def field(*args); end

  def kind_sym(); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Meta::V1::StatusCause
end

class KubeDSL::DSL::Meta::V1::StatusDetails
  def cause(elem_name=T.unsafe(nil), &block); end

  def causes(); end

  def group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def retry_after_seconds(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::Meta::V1::StatusDetails
end

class KubeDSL::DSL::Meta::V1::WatchEvent
  def kind_sym(); end

  def object(*args); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::Meta::V1::WatchEvent
end

module KubeDSL::DSL::Networking
end

module KubeDSL::DSL::Networking::V1
end

class KubeDSL::DSL::Networking::V1::IPBlock
  def cidr(*args); end

  def except(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::IPBlock
end

class KubeDSL::DSL::Networking::V1::NetworkPolicy
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicy
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyEgressRule
  def kind_sym(); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end

  def to(elem_name=T.unsafe(nil), &block); end

  def tos(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyEgressRule
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyIngressRule
  def from(elem_name=T.unsafe(nil), &block); end

  def froms(); end

  def kind_sym(); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyIngressRule
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyList
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPeer
  def ip_block(*args, &block); end

  def kind_sym(); end

  def namespace_selector(*args, &block); end

  def pod_selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPeer
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPort
  def kind_sym(); end

  def port(*args); end

  def protocol(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicyPort
end

class KubeDSL::DSL::Networking::V1::NetworkPolicySpec
  def egress(elem_name=T.unsafe(nil), &block); end

  def egresses(); end

  def ingress(elem_name=T.unsafe(nil), &block); end

  def ingresses(); end

  def kind_sym(); end

  def pod_selector(*args, &block); end

  def policy_types(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1::NetworkPolicySpec
end

module KubeDSL::DSL::Networking::V1
end

module KubeDSL::DSL::Networking::V1beta1
end

class KubeDSL::DSL::Networking::V1beta1::HTTPIngressPath
  def backend(*args, &block); end

  def kind_sym(); end

  def path(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::HTTPIngressPath
end

class KubeDSL::DSL::Networking::V1beta1::HTTPIngressRuleValue
  def kind_sym(); end

  def path(elem_name=T.unsafe(nil), &block); end

  def paths(); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::HTTPIngressRuleValue
end

class KubeDSL::DSL::Networking::V1beta1::Ingress
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Networking::V1beta1::Ingress
end

class KubeDSL::DSL::Networking::V1beta1::IngressBackend
  def kind_sym(); end

  def serialize(); end

  def service_name(*args); end

  def service_port(*args); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressBackend
end

class KubeDSL::DSL::Networking::V1beta1::IngressList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressList
end

class KubeDSL::DSL::Networking::V1beta1::IngressRule
  def host(*args); end

  def http(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressRule
end

class KubeDSL::DSL::Networking::V1beta1::IngressSpec
  def backend(*args, &block); end

  def kind_sym(); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end

  def tls(elem_name=T.unsafe(nil), &block); end

  def tlses(); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressSpec
end

class KubeDSL::DSL::Networking::V1beta1::IngressStatus
  def kind_sym(); end

  def load_balancer(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressStatus
end

class KubeDSL::DSL::Networking::V1beta1::IngressTLS
  def hosts(*args); end

  def kind_sym(); end

  def secret_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Networking::V1beta1::IngressTLS
end

module KubeDSL::DSL::Networking::V1beta1
end

module KubeDSL::DSL::Networking
end

module KubeDSL::DSL::Node
end

module KubeDSL::DSL::Node::V1alpha1
end

class KubeDSL::DSL::Node::V1alpha1::Overhead
  def kind_sym(); end

  def pod_fixed(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1alpha1::Overhead
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClass
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClass
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassList
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassSpec
  def kind_sym(); end

  def overhead(*args, &block); end

  def runtime_handler(*args); end

  def scheduling(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1alpha1::RuntimeClassSpec
end

class KubeDSL::DSL::Node::V1alpha1::Scheduling
  def kind_sym(); end

  def node_selector(*args, &block); end

  def serialize(); end

  def toleration(elem_name=T.unsafe(nil), &block); end

  def tolerations(); end
end

class KubeDSL::DSL::Node::V1alpha1::Scheduling
end

module KubeDSL::DSL::Node::V1alpha1
end

module KubeDSL::DSL::Node::V1beta1
end

class KubeDSL::DSL::Node::V1beta1::Overhead
  def kind_sym(); end

  def pod_fixed(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1beta1::Overhead
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClass
  def handler(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def overhead(*args, &block); end

  def scheduling(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClass
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Node::V1beta1::RuntimeClassList
end

class KubeDSL::DSL::Node::V1beta1::Scheduling
  def kind_sym(); end

  def node_selector(*args, &block); end

  def serialize(); end

  def toleration(elem_name=T.unsafe(nil), &block); end

  def tolerations(); end
end

class KubeDSL::DSL::Node::V1beta1::Scheduling
end

module KubeDSL::DSL::Node::V1beta1
end

module KubeDSL::DSL::Node
end

module KubeDSL::DSL::Pkg
end

module KubeDSL::DSL::Pkg::Version
end

class KubeDSL::DSL::Pkg::Version::Info
  def build_date(*args); end

  def compiler(*args); end

  def git_commit(*args); end

  def git_tree_state(*args); end

  def git_version(*args); end

  def go_version(*args); end

  def kind_sym(); end

  def major(*args); end

  def minor(*args); end

  def platform(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Pkg::Version::Info
end

module KubeDSL::DSL::Pkg::Version
end

module KubeDSL::DSL::Pkg
end

module KubeDSL::DSL::Policy
end

module KubeDSL::DSL::Policy::V1beta1
end

class KubeDSL::DSL::Policy::V1beta1::AllowedCSIDriver
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::AllowedCSIDriver
end

class KubeDSL::DSL::Policy::V1beta1::AllowedFlexVolume
  def driver(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::AllowedFlexVolume
end

class KubeDSL::DSL::Policy::V1beta1::AllowedHostPath
  def kind_sym(); end

  def path_prefix(*args); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::AllowedHostPath
end

class KubeDSL::DSL::Policy::V1beta1::Eviction
  def delete_options(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::Eviction
end

class KubeDSL::DSL::Policy::V1beta1::FSGroupStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::FSGroupStrategyOptions
end

class KubeDSL::DSL::Policy::V1beta1::HostPortRange
  def kind_sym(); end

  def max(*args); end

  def min(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::HostPortRange
end

class KubeDSL::DSL::Policy::V1beta1::IDRange
  def kind_sym(); end

  def max(*args); end

  def min(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::IDRange
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudget
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudget
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetList
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetSpec
  def kind_sym(); end

  def max_unavailable(*args); end

  def min_available(*args); end

  def selector(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetSpec
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetStatus
  def current_healthy(*args); end

  def desired_healthy(*args); end

  def disrupted_pods(*args, &block); end

  def disruptions_allowed(*args); end

  def expected_pods(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::PodDisruptionBudgetStatus
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicy
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicy
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicyList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicyList
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicySpec
  def allow_privilege_escalation(*args); end

  def allowed_capabilities(*args); end

  def allowed_csi_driver(elem_name=T.unsafe(nil), &block); end

  def allowed_csi_drivers(); end

  def allowed_flex_volume(elem_name=T.unsafe(nil), &block); end

  def allowed_flex_volumes(); end

  def allowed_host_path(elem_name=T.unsafe(nil), &block); end

  def allowed_host_paths(); end

  def allowed_proc_mount_types(*args); end

  def allowed_unsafe_sysctls(*args); end

  def default_add_capabilities(*args); end

  def default_allow_privilege_escalation(*args); end

  def forbidden_sysctls(*args); end

  def fs_group(*args, &block); end

  def host_ipc(*args); end

  def host_network(*args); end

  def host_pid(*args); end

  def host_port(elem_name=T.unsafe(nil), &block); end

  def host_ports(); end

  def kind_sym(); end

  def privileged(*args); end

  def read_only_root_filesystem(*args); end

  def required_drop_capabilities(*args); end

  def run_as_group(*args, &block); end

  def run_as_user(*args, &block); end

  def runtime_class(*args, &block); end

  def se_linux(*args, &block); end

  def serialize(); end

  def supplemental_groups(*args, &block); end

  def volumes(*args); end
end

class KubeDSL::DSL::Policy::V1beta1::PodSecurityPolicySpec
end

class KubeDSL::DSL::Policy::V1beta1::RunAsGroupStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::RunAsGroupStrategyOptions
end

class KubeDSL::DSL::Policy::V1beta1::RunAsUserStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::RunAsUserStrategyOptions
end

class KubeDSL::DSL::Policy::V1beta1::RuntimeClassStrategyOptions
  def allowed_runtime_class_names(*args); end

  def default_runtime_class_name(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::RuntimeClassStrategyOptions
end

class KubeDSL::DSL::Policy::V1beta1::SELinuxStrategyOptions
  def kind_sym(); end

  def rule(*args); end

  def se_linux_options(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::SELinuxStrategyOptions
end

class KubeDSL::DSL::Policy::V1beta1::SupplementalGroupsStrategyOptions
  def kind_sym(); end

  def range(elem_name=T.unsafe(nil), &block); end

  def ranges(); end

  def rule(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Policy::V1beta1::SupplementalGroupsStrategyOptions
end

module KubeDSL::DSL::Policy::V1beta1
end

module KubeDSL::DSL::Policy
end

module KubeDSL::DSL::Rbac
end

module KubeDSL::DSL::Rbac::V1
end

class KubeDSL::DSL::Rbac::V1::AggregationRule
  def cluster_role_selector(elem_name=T.unsafe(nil), &block); end

  def cluster_role_selectors(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::AggregationRule
end

class KubeDSL::DSL::Rbac::V1::ClusterRole
  def aggregation_rule(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::ClusterRole
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBinding
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleBindingList
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::ClusterRoleList
end

class KubeDSL::DSL::Rbac::V1::PolicyRule
  def api_groups(*args); end

  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def resource_names(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Rbac::V1::PolicyRule
end

class KubeDSL::DSL::Rbac::V1::Role
  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::Role
end

class KubeDSL::DSL::Rbac::V1::RoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1::RoleBinding
end

class KubeDSL::DSL::Rbac::V1::RoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::RoleBindingList
end

class KubeDSL::DSL::Rbac::V1::RoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::RoleList
end

class KubeDSL::DSL::Rbac::V1::RoleRef
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::RoleRef
end

class KubeDSL::DSL::Rbac::V1::Subject
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1::Subject
end

module KubeDSL::DSL::Rbac::V1
end

module KubeDSL::DSL::Rbac::V1alpha1
end

class KubeDSL::DSL::Rbac::V1alpha1::AggregationRule
  def cluster_role_selector(elem_name=T.unsafe(nil), &block); end

  def cluster_role_selectors(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::AggregationRule
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRole
  def aggregation_rule(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRole
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBinding
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleBindingList
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::ClusterRoleList
end

class KubeDSL::DSL::Rbac::V1alpha1::PolicyRule
  def api_groups(*args); end

  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def resource_names(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Rbac::V1alpha1::PolicyRule
end

class KubeDSL::DSL::Rbac::V1alpha1::Role
  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::Role
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBinding
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleBindingList
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleList
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleRef
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::RoleRef
end

class KubeDSL::DSL::Rbac::V1alpha1::Subject
  def api_version(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1alpha1::Subject
end

module KubeDSL::DSL::Rbac::V1alpha1
end

module KubeDSL::DSL::Rbac::V1beta1
end

class KubeDSL::DSL::Rbac::V1beta1::AggregationRule
  def cluster_role_selector(elem_name=T.unsafe(nil), &block); end

  def cluster_role_selectors(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::AggregationRule
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRole
  def aggregation_rule(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRole
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleBinding
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleBindingList
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::ClusterRoleList
end

class KubeDSL::DSL::Rbac::V1beta1::PolicyRule
  def api_groups(*args); end

  def kind_sym(); end

  def non_resource_ur_ls(*args); end

  def resource_names(*args); end

  def resources(*args); end

  def serialize(); end

  def verbs(*args); end
end

class KubeDSL::DSL::Rbac::V1beta1::PolicyRule
end

class KubeDSL::DSL::Rbac::V1beta1::Role
  def kind_sym(); end

  def metadata(*args, &block); end

  def rule(elem_name=T.unsafe(nil), &block); end

  def rules(); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::Role
end

class KubeDSL::DSL::Rbac::V1beta1::RoleBinding
  def kind_sym(); end

  def metadata(*args, &block); end

  def role_ref(*args, &block); end

  def serialize(); end

  def subject(elem_name=T.unsafe(nil), &block); end

  def subjects(); end
end

class KubeDSL::DSL::Rbac::V1beta1::RoleBinding
end

class KubeDSL::DSL::Rbac::V1beta1::RoleBindingList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::RoleBindingList
end

class KubeDSL::DSL::Rbac::V1beta1::RoleList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::RoleList
end

class KubeDSL::DSL::Rbac::V1beta1::RoleRef
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::RoleRef
end

class KubeDSL::DSL::Rbac::V1beta1::Subject
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Rbac::V1beta1::Subject
end

module KubeDSL::DSL::Rbac::V1beta1
end

module KubeDSL::DSL::Rbac
end

module KubeDSL::DSL::Scheduling
end

module KubeDSL::DSL::Scheduling::V1
end

class KubeDSL::DSL::Scheduling::V1::PriorityClass
  def description(*args); end

  def global_default(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def preemption_policy(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::Scheduling::V1::PriorityClass
end

class KubeDSL::DSL::Scheduling::V1::PriorityClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Scheduling::V1::PriorityClassList
end

module KubeDSL::DSL::Scheduling::V1
end

module KubeDSL::DSL::Scheduling::V1alpha1
end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClass
  def description(*args); end

  def global_default(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def preemption_policy(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClass
end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Scheduling::V1alpha1::PriorityClassList
end

module KubeDSL::DSL::Scheduling::V1alpha1
end

module KubeDSL::DSL::Scheduling::V1beta1
end

class KubeDSL::DSL::Scheduling::V1beta1::PriorityClass
  def description(*args); end

  def global_default(*args); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def preemption_policy(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::Scheduling::V1beta1::PriorityClass
end

class KubeDSL::DSL::Scheduling::V1beta1::PriorityClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Scheduling::V1beta1::PriorityClassList
end

module KubeDSL::DSL::Scheduling::V1beta1
end

module KubeDSL::DSL::Scheduling
end

module KubeDSL::DSL::Settings
end

module KubeDSL::DSL::Settings::V1alpha1
end

class KubeDSL::DSL::Settings::V1alpha1::PodPreset
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Settings::V1alpha1::PodPreset
end

class KubeDSL::DSL::Settings::V1alpha1::PodPresetList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Settings::V1alpha1::PodPresetList
end

class KubeDSL::DSL::Settings::V1alpha1::PodPresetSpec
  def env(elem_name=T.unsafe(nil), &block); end

  def env_from(elem_name=T.unsafe(nil), &block); end

  def env_froms(); end

  def envs(); end

  def kind_sym(); end

  def selector(*args, &block); end

  def serialize(); end

  def volume(elem_name=T.unsafe(nil), &block); end

  def volume_mount(elem_name=T.unsafe(nil), &block); end

  def volume_mounts(); end

  def volumes(); end
end

class KubeDSL::DSL::Settings::V1alpha1::PodPresetSpec
end

module KubeDSL::DSL::Settings::V1alpha1
end

module KubeDSL::DSL::Settings
end

module KubeDSL::DSL::Storage
end

module KubeDSL::DSL::Storage::V1
end

class KubeDSL::DSL::Storage::V1::CSINode
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Storage::V1::CSINode
end

class KubeDSL::DSL::Storage::V1::CSINodeDriver
  def allocatable(*args, &block); end

  def kind_sym(); end

  def name(*args); end

  def node_id(*args); end

  def serialize(); end

  def topology_keys(*args); end
end

class KubeDSL::DSL::Storage::V1::CSINodeDriver
end

class KubeDSL::DSL::Storage::V1::CSINodeList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::CSINodeList
end

class KubeDSL::DSL::Storage::V1::CSINodeSpec
  def driver(elem_name=T.unsafe(nil), &block); end

  def drivers(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::CSINodeSpec
end

class KubeDSL::DSL::Storage::V1::StorageClass
  def allow_volume_expansion(*args); end

  def allowed_topologies(); end

  def allowed_topology(elem_name=T.unsafe(nil), &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def mount_options(*args); end

  def parameters(*args, &block); end

  def provisioner(*args); end

  def reclaim_policy(*args); end

  def serialize(); end

  def volume_binding_mode(*args); end
end

class KubeDSL::DSL::Storage::V1::StorageClass
end

class KubeDSL::DSL::Storage::V1::StorageClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::StorageClassList
end

class KubeDSL::DSL::Storage::V1::VolumeAttachment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachment
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentList
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSource
  def inline_volume_spec(*args, &block); end

  def kind_sym(); end

  def persistent_volume_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSource
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSpec
  def attacher(*args); end

  def kind_sym(); end

  def node_name(*args); end

  def serialize(); end

  def source(*args, &block); end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentSpec
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentStatus
  def attach_error(*args, &block); end

  def attached(*args); end

  def attachment_metadata(*args, &block); end

  def detach_error(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::VolumeAttachmentStatus
end

class KubeDSL::DSL::Storage::V1::VolumeError
  def kind_sym(); end

  def message(*args); end

  def serialize(); end

  def time(*args); end
end

class KubeDSL::DSL::Storage::V1::VolumeError
end

class KubeDSL::DSL::Storage::V1::VolumeNodeResources
  def count(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1::VolumeNodeResources
end

module KubeDSL::DSL::Storage::V1
end

module KubeDSL::DSL::Storage::V1alpha1
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachment
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentList
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSource
  def inline_volume_spec(*args, &block); end

  def kind_sym(); end

  def persistent_volume_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSource
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSpec
  def attacher(*args); end

  def kind_sym(); end

  def node_name(*args); end

  def serialize(); end

  def source(*args, &block); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentSpec
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentStatus
  def attach_error(*args, &block); end

  def attached(*args); end

  def attachment_metadata(*args, &block); end

  def detach_error(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeAttachmentStatus
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeError
  def kind_sym(); end

  def message(*args); end

  def serialize(); end

  def time(*args); end
end

class KubeDSL::DSL::Storage::V1alpha1::VolumeError
end

module KubeDSL::DSL::Storage::V1alpha1
end

module KubeDSL::DSL::Storage::V1beta1
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriver
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriver
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriverList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriverList
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriverSpec
  def attach_required(*args); end

  def kind_sym(); end

  def pod_info_on_mount(*args); end

  def serialize(); end

  def volume_lifecycle_modes(*args); end
end

class KubeDSL::DSL::Storage::V1beta1::CSIDriverSpec
end

class KubeDSL::DSL::Storage::V1beta1::CSINode
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::Storage::V1beta1::CSINode
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeDriver
  def allocatable(*args, &block); end

  def kind_sym(); end

  def name(*args); end

  def node_id(*args); end

  def serialize(); end

  def topology_keys(*args); end
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeDriver
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeList
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeSpec
  def driver(elem_name=T.unsafe(nil), &block); end

  def drivers(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::CSINodeSpec
end

class KubeDSL::DSL::Storage::V1beta1::StorageClass
  def allow_volume_expansion(*args); end

  def allowed_topologies(); end

  def allowed_topology(elem_name=T.unsafe(nil), &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def mount_options(*args); end

  def parameters(*args, &block); end

  def provisioner(*args); end

  def reclaim_policy(*args); end

  def serialize(); end

  def volume_binding_mode(*args); end
end

class KubeDSL::DSL::Storage::V1beta1::StorageClass
end

class KubeDSL::DSL::Storage::V1beta1::StorageClassList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::StorageClassList
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachment
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachment
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentList
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentSource
  def inline_volume_spec(*args, &block); end

  def kind_sym(); end

  def persistent_volume_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentSource
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentSpec
  def attacher(*args); end

  def kind_sym(); end

  def node_name(*args); end

  def serialize(); end

  def source(*args, &block); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentSpec
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentStatus
  def attach_error(*args, &block); end

  def attached(*args); end

  def attachment_metadata(*args, &block); end

  def detach_error(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeAttachmentStatus
end

class KubeDSL::DSL::Storage::V1beta1::VolumeError
  def kind_sym(); end

  def message(*args); end

  def serialize(); end

  def time(*args); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeError
end

class KubeDSL::DSL::Storage::V1beta1::VolumeNodeResources
  def count(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::Storage::V1beta1::VolumeNodeResources
end

module KubeDSL::DSL::Storage::V1beta1
end

module KubeDSL::DSL::Storage
end

module KubeDSL::DSL::V1
end

class KubeDSL::DSL::V1::AWSElasticBlockStoreVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def partition(*args); end

  def read_only(*args); end

  def serialize(); end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::AWSElasticBlockStoreVolumeSource
end

class KubeDSL::DSL::V1::Affinity
  def kind_sym(); end

  def node_affinity(*args, &block); end

  def pod_affinity(*args, &block); end

  def pod_anti_affinity(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::Affinity
end

class KubeDSL::DSL::V1::AttachedVolume
  def device_path(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::AttachedVolume
end

class KubeDSL::DSL::V1::AzureDiskVolumeSource
  def caching_mode(*args); end

  def disk_name(*args); end

  def disk_uri(*args); end

  def fs_type(*args); end

  def kind(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::AzureDiskVolumeSource
end

class KubeDSL::DSL::V1::AzureFilePersistentVolumeSource
  def kind_sym(); end

  def read_only(*args); end

  def secret_name(*args); end

  def secret_namespace(*args); end

  def serialize(); end

  def share_name(*args); end
end

class KubeDSL::DSL::V1::AzureFilePersistentVolumeSource
end

class KubeDSL::DSL::V1::AzureFileVolumeSource
  def kind_sym(); end

  def read_only(*args); end

  def secret_name(*args); end

  def serialize(); end

  def share_name(*args); end
end

class KubeDSL::DSL::V1::AzureFileVolumeSource
end

class KubeDSL::DSL::V1::Binding
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def target(*args, &block); end
end

class KubeDSL::DSL::V1::Binding
end

class KubeDSL::DSL::V1::CSIPersistentVolumeSource
  def controller_expand_secret_ref(*args, &block); end

  def controller_publish_secret_ref(*args, &block); end

  def driver(*args); end

  def fs_type(*args); end

  def kind_sym(); end

  def node_publish_secret_ref(*args, &block); end

  def node_stage_secret_ref(*args, &block); end

  def read_only(*args); end

  def serialize(); end

  def volume_attributes(*args, &block); end

  def volume_handle(*args); end
end

class KubeDSL::DSL::V1::CSIPersistentVolumeSource
end

class KubeDSL::DSL::V1::CSIVolumeSource
  def driver(*args); end

  def fs_type(*args); end

  def kind_sym(); end

  def node_publish_secret_ref(*args, &block); end

  def read_only(*args); end

  def serialize(); end

  def volume_attributes(*args, &block); end
end

class KubeDSL::DSL::V1::CSIVolumeSource
end

class KubeDSL::DSL::V1::Capabilities
  def add(*args); end

  def drop(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::Capabilities
end

class KubeDSL::DSL::V1::CephFSPersistentVolumeSource
  def kind_sym(); end

  def monitors(*args); end

  def path(*args); end

  def read_only(*args); end

  def secret_file(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def user(*args); end
end

class KubeDSL::DSL::V1::CephFSPersistentVolumeSource
end

class KubeDSL::DSL::V1::CephFSVolumeSource
  def kind_sym(); end

  def monitors(*args); end

  def path(*args); end

  def read_only(*args); end

  def secret_file(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def user(*args); end
end

class KubeDSL::DSL::V1::CephFSVolumeSource
end

class KubeDSL::DSL::V1::CinderPersistentVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::CinderPersistentVolumeSource
end

class KubeDSL::DSL::V1::CinderVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::CinderVolumeSource
end

class KubeDSL::DSL::V1::ClientIPConfig
  def kind_sym(); end

  def serialize(); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::V1::ClientIPConfig
end

class KubeDSL::DSL::V1::ComponentCondition
  def error(*args); end

  def kind_sym(); end

  def message(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::ComponentCondition
end

class KubeDSL::DSL::V1::ComponentStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ComponentStatus
end

class KubeDSL::DSL::V1::ComponentStatusList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ComponentStatusList
end

class KubeDSL::DSL::V1::ConfigMap
  def binary_data(*args, &block); end

  def data(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMap
end

class KubeDSL::DSL::V1::ConfigMapEnvSource
  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMapEnvSource
end

class KubeDSL::DSL::V1::ConfigMapKeySelector
  def key(*args); end

  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMapKeySelector
end

class KubeDSL::DSL::V1::ConfigMapList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMapList
end

class KubeDSL::DSL::V1::ConfigMapNodeConfigSource
  def kind_sym(); end

  def kubelet_config_key(*args); end

  def name(*args); end

  def namespace(*args); end

  def resource_version(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::V1::ConfigMapNodeConfigSource
end

class KubeDSL::DSL::V1::ConfigMapProjection
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMapProjection
end

class KubeDSL::DSL::V1::ConfigMapVolumeSource
  def default_mode(*args); end

  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ConfigMapVolumeSource
end

class KubeDSL::DSL::V1::Container
  def args(*args); end

  def command(*args); end

  def env(elem_name=T.unsafe(nil), &block); end

  def env_from(elem_name=T.unsafe(nil), &block); end

  def env_froms(); end

  def envs(); end

  def image(*args); end

  def image_pull_policy(*args); end

  def kind_sym(); end

  def lifecycle(*args, &block); end

  def liveness_probe(*args, &block); end

  def name(*args); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def readiness_probe(*args, &block); end

  def resources(*args, &block); end

  def security_context(*args, &block); end

  def serialize(); end

  def startup_probe(*args, &block); end

  def stdin(*args); end

  def stdin_once(*args); end

  def termination_message_path(*args); end

  def termination_message_policy(*args); end

  def tty(*args); end

  def volume_device(elem_name=T.unsafe(nil), &block); end

  def volume_devices(); end

  def volume_mount(elem_name=T.unsafe(nil), &block); end

  def volume_mounts(); end

  def working_dir(*args); end
end

class KubeDSL::DSL::V1::Container
end

class KubeDSL::DSL::V1::ContainerImage
  def kind_sym(); end

  def names(*args); end

  def serialize(); end

  def size_bytes(*args); end
end

class KubeDSL::DSL::V1::ContainerImage
end

class KubeDSL::DSL::V1::ContainerPort
  def container_port(*args); end

  def host_ip(*args); end

  def host_port(*args); end

  def kind_sym(); end

  def name(*args); end

  def protocol(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ContainerPort
end

class KubeDSL::DSL::V1::ContainerState
  def kind_sym(); end

  def running(*args, &block); end

  def serialize(); end

  def terminated(*args, &block); end

  def waiting(*args, &block); end
end

class KubeDSL::DSL::V1::ContainerState
end

class KubeDSL::DSL::V1::ContainerStateRunning
  def kind_sym(); end

  def serialize(); end

  def started_at(*args); end
end

class KubeDSL::DSL::V1::ContainerStateRunning
end

class KubeDSL::DSL::V1::ContainerStateTerminated
  def container_id(*args); end

  def exit_code(*args); end

  def finished_at(*args); end

  def kind_sym(); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def signal(*args); end

  def started_at(*args); end
end

class KubeDSL::DSL::V1::ContainerStateTerminated
end

class KubeDSL::DSL::V1::ContainerStateWaiting
  def kind_sym(); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ContainerStateWaiting
end

class KubeDSL::DSL::V1::ContainerStatus
  def container_id(*args); end

  def image(*args); end

  def image_id(*args); end

  def kind_sym(); end

  def last_state(*args, &block); end

  def name(*args); end

  def ready(*args); end

  def restart_count(*args); end

  def serialize(); end

  def started(*args); end

  def state(*args, &block); end
end

class KubeDSL::DSL::V1::ContainerStatus
end

class KubeDSL::DSL::V1::DaemonEndpoint
  def kind_sym(); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::DaemonEndpoint
end

class KubeDSL::DSL::V1::DownwardAPIProjection
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::DownwardAPIProjection
end

class KubeDSL::DSL::V1::DownwardAPIVolumeFile
  def field_ref(*args, &block); end

  def kind_sym(); end

  def mode(*args); end

  def path(*args); end

  def resource_field_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::DownwardAPIVolumeFile
end

class KubeDSL::DSL::V1::DownwardAPIVolumeSource
  def default_mode(*args); end

  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::DownwardAPIVolumeSource
end

class KubeDSL::DSL::V1::EmptyDirVolumeSource
  def kind_sym(); end

  def medium(*args); end

  def serialize(); end

  def size_limit(*args); end
end

class KubeDSL::DSL::V1::EmptyDirVolumeSource
end

class KubeDSL::DSL::V1::EndpointAddress
  def hostname(*args); end

  def ip(*args); end

  def kind_sym(); end

  def node_name(*args); end

  def serialize(); end

  def target_ref(*args, &block); end
end

class KubeDSL::DSL::V1::EndpointAddress
end

class KubeDSL::DSL::V1::EndpointPort
  def kind_sym(); end

  def name(*args); end

  def port(*args); end

  def protocol(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EndpointPort
end

class KubeDSL::DSL::V1::EndpointSubset
  def address(elem_name=T.unsafe(nil), &block); end

  def addresses(); end

  def kind_sym(); end

  def not_ready_address(elem_name=T.unsafe(nil), &block); end

  def not_ready_addresses(); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EndpointSubset
end

class KubeDSL::DSL::V1::Endpoints
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def subset(elem_name=T.unsafe(nil), &block); end

  def subsets(); end
end

class KubeDSL::DSL::V1::Endpoints
end

class KubeDSL::DSL::V1::EndpointsList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EndpointsList
end

class KubeDSL::DSL::V1::EnvFromSource
  def config_map_ref(*args, &block); end

  def kind_sym(); end

  def prefix(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EnvFromSource
end

class KubeDSL::DSL::V1::EnvVar
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def value(*args); end

  def value_from(*args, &block); end
end

class KubeDSL::DSL::V1::EnvVar
end

class KubeDSL::DSL::V1::EnvVarSource
  def config_map_key_ref(*args, &block); end

  def field_ref(*args, &block); end

  def kind_sym(); end

  def resource_field_ref(*args, &block); end

  def secret_key_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EnvVarSource
end

class KubeDSL::DSL::V1::EphemeralContainer
  def args(*args); end

  def command(*args); end

  def env(elem_name=T.unsafe(nil), &block); end

  def env_from(elem_name=T.unsafe(nil), &block); end

  def env_froms(); end

  def envs(); end

  def image(*args); end

  def image_pull_policy(*args); end

  def kind_sym(); end

  def lifecycle(*args, &block); end

  def liveness_probe(*args, &block); end

  def name(*args); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def readiness_probe(*args, &block); end

  def resources(*args, &block); end

  def security_context(*args, &block); end

  def serialize(); end

  def startup_probe(*args, &block); end

  def stdin(*args); end

  def stdin_once(*args); end

  def target_container_name(*args); end

  def termination_message_path(*args); end

  def termination_message_policy(*args); end

  def tty(*args); end

  def volume_device(elem_name=T.unsafe(nil), &block); end

  def volume_devices(); end

  def volume_mount(elem_name=T.unsafe(nil), &block); end

  def volume_mounts(); end

  def working_dir(*args); end
end

class KubeDSL::DSL::V1::EphemeralContainer
end

class KubeDSL::DSL::V1::Event
  def action(*args); end

  def count(*args); end

  def event_time(*args); end

  def first_timestamp(*args); end

  def involved_object(*args, &block); end

  def kind_sym(); end

  def last_timestamp(*args); end

  def message(*args); end

  def metadata(*args, &block); end

  def reason(*args); end

  def related(*args, &block); end

  def reporting_component(*args); end

  def reporting_instance(*args); end

  def serialize(); end

  def series(*args, &block); end

  def source(*args, &block); end

  def type(*args); end
end

class KubeDSL::DSL::V1::Event
end

class KubeDSL::DSL::V1::EventList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EventList
end

class KubeDSL::DSL::V1::EventSeries
  def count(*args); end

  def kind_sym(); end

  def last_observed_time(*args); end

  def serialize(); end

  def state(*args); end
end

class KubeDSL::DSL::V1::EventSeries
end

class KubeDSL::DSL::V1::EventSource
  def component(*args); end

  def host(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::EventSource
end

class KubeDSL::DSL::V1::ExecAction
  def command(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ExecAction
end

class KubeDSL::DSL::V1::FCVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def lun(*args); end

  def read_only(*args); end

  def serialize(); end

  def target_ww_ns(*args); end

  def wwids(*args); end
end

class KubeDSL::DSL::V1::FCVolumeSource
end

class KubeDSL::DSL::V1::FlexPersistentVolumeSource
  def driver(*args); end

  def fs_type(*args); end

  def kind_sym(); end

  def options(*args, &block); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::FlexPersistentVolumeSource
end

class KubeDSL::DSL::V1::FlexVolumeSource
  def driver(*args); end

  def fs_type(*args); end

  def kind_sym(); end

  def options(*args, &block); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::FlexVolumeSource
end

class KubeDSL::DSL::V1::FlockerVolumeSource
  def dataset_name(*args); end

  def dataset_uuid(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::FlockerVolumeSource
end

class KubeDSL::DSL::V1::GCEPersistentDiskVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def partition(*args); end

  def pd_name(*args); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::GCEPersistentDiskVolumeSource
end

class KubeDSL::DSL::V1::GitRepoVolumeSource
  def directory(*args); end

  def kind_sym(); end

  def repository(*args); end

  def revision(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::GitRepoVolumeSource
end

class KubeDSL::DSL::V1::GlusterfsPersistentVolumeSource
  def endpoints(*args); end

  def endpoints_namespace(*args); end

  def kind_sym(); end

  def path(*args); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::GlusterfsPersistentVolumeSource
end

class KubeDSL::DSL::V1::GlusterfsVolumeSource
  def endpoints(*args); end

  def kind_sym(); end

  def path(*args); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::GlusterfsVolumeSource
end

class KubeDSL::DSL::V1::HTTPGetAction
  def host(*args); end

  def http_header(elem_name=T.unsafe(nil), &block); end

  def http_headers(); end

  def kind_sym(); end

  def path(*args); end

  def port(*args); end

  def scheme(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::HTTPGetAction
end

class KubeDSL::DSL::V1::HTTPHeader
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::V1::HTTPHeader
end

class KubeDSL::DSL::V1::Handler
  def exec(*args, &block); end

  def http_get(*args, &block); end

  def kind_sym(); end

  def serialize(); end

  def tcp_socket(*args, &block); end
end

class KubeDSL::DSL::V1::Handler
end

class KubeDSL::DSL::V1::HostAlias
  def hostnames(*args); end

  def ip(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::HostAlias
end

class KubeDSL::DSL::V1::HostPathVolumeSource
  def kind_sym(); end

  def path(*args); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::V1::HostPathVolumeSource
end

class KubeDSL::DSL::V1::ISCSIPersistentVolumeSource
  def chap_auth_discovery(*args); end

  def chap_auth_session(*args); end

  def fs_type(*args); end

  def initiator_name(*args); end

  def iqn(*args); end

  def iscsi_interface(*args); end

  def kind_sym(); end

  def lun(*args); end

  def portals(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def target_portal(*args); end
end

class KubeDSL::DSL::V1::ISCSIPersistentVolumeSource
end

class KubeDSL::DSL::V1::ISCSIVolumeSource
  def chap_auth_discovery(*args); end

  def chap_auth_session(*args); end

  def fs_type(*args); end

  def initiator_name(*args); end

  def iqn(*args); end

  def iscsi_interface(*args); end

  def kind_sym(); end

  def lun(*args); end

  def portals(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def target_portal(*args); end
end

class KubeDSL::DSL::V1::ISCSIVolumeSource
end

class KubeDSL::DSL::V1::KeyToPath
  def key(*args); end

  def kind_sym(); end

  def mode(*args); end

  def path(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::KeyToPath
end

class KubeDSL::DSL::V1::Lifecycle
  def kind_sym(); end

  def post_start(*args, &block); end

  def pre_stop(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::Lifecycle
end

class KubeDSL::DSL::V1::LimitRange
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::V1::LimitRange
end

class KubeDSL::DSL::V1::LimitRangeItem
  def default(*args, &block); end

  def default_request(*args, &block); end

  def kind_sym(); end

  def max(*args, &block); end

  def max_limit_request_ratio(*args, &block); end

  def min(*args, &block); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::V1::LimitRangeItem
end

class KubeDSL::DSL::V1::LimitRangeList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LimitRangeList
end

class KubeDSL::DSL::V1::LimitRangeSpec
  def kind_sym(); end

  def limit(elem_name=T.unsafe(nil), &block); end

  def limits(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LimitRangeSpec
end

class KubeDSL::DSL::V1::LoadBalancerIngress
  def hostname(*args); end

  def ip(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LoadBalancerIngress
end

class KubeDSL::DSL::V1::LoadBalancerStatus
  def ingress(elem_name=T.unsafe(nil), &block); end

  def ingresses(); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LoadBalancerStatus
end

class KubeDSL::DSL::V1::LocalObjectReference
  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LocalObjectReference
end

class KubeDSL::DSL::V1::LocalVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def path(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::LocalVolumeSource
end

class KubeDSL::DSL::V1::NFSVolumeSource
  def kind_sym(); end

  def path(*args); end

  def read_only(*args); end

  def serialize(); end

  def server(*args); end
end

class KubeDSL::DSL::V1::NFSVolumeSource
end

class KubeDSL::DSL::V1::Namespace
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::Namespace
end

class KubeDSL::DSL::V1::NamespaceCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::NamespaceCondition
end

class KubeDSL::DSL::V1::NamespaceList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NamespaceList
end

class KubeDSL::DSL::V1::NamespaceSpec
  def finalizers(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NamespaceSpec
end

class KubeDSL::DSL::V1::NamespaceStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def phase(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NamespaceStatus
end

class KubeDSL::DSL::V1::Node
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::Node
end

class KubeDSL::DSL::V1::NodeAddress
  def address(*args); end

  def kind_sym(); end

  def serialize(); end

  def type(*args); end
end

class KubeDSL::DSL::V1::NodeAddress
end

class KubeDSL::DSL::V1::NodeAffinity
  def kind_sym(); end

  def preferred_during_scheduling_ignored_during_execution(elem_name=T.unsafe(nil), &block); end

  def preferred_during_scheduling_ignored_during_executions(); end

  def required_during_scheduling_ignored_during_execution(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeAffinity
end

class KubeDSL::DSL::V1::NodeCondition
  def kind_sym(); end

  def last_heartbeat_time(*args); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::NodeCondition
end

class KubeDSL::DSL::V1::NodeConfigSource
  def config_map(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeConfigSource
end

class KubeDSL::DSL::V1::NodeConfigStatus
  def active(*args, &block); end

  def assigned(*args, &block); end

  def error(*args); end

  def kind_sym(); end

  def last_known_good(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeConfigStatus
end

class KubeDSL::DSL::V1::NodeDaemonEndpoints
  def kind_sym(); end

  def kubelet_endpoint(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeDaemonEndpoints
end

class KubeDSL::DSL::V1::NodeList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeList
end

class KubeDSL::DSL::V1::NodeSelector
  def kind_sym(); end

  def node_selector_term(elem_name=T.unsafe(nil), &block); end

  def node_selector_terms(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeSelector
end

class KubeDSL::DSL::V1::NodeSelectorRequirement
  def key(*args); end

  def kind_sym(); end

  def operator(*args); end

  def serialize(); end

  def values(*args); end
end

class KubeDSL::DSL::V1::NodeSelectorRequirement
end

class KubeDSL::DSL::V1::NodeSelectorTerm
  def kind_sym(); end

  def match_expression(elem_name=T.unsafe(nil), &block); end

  def match_expressions(); end

  def match_field(elem_name=T.unsafe(nil), &block); end

  def match_fields(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::NodeSelectorTerm
end

class KubeDSL::DSL::V1::NodeSpec
  def config_source(*args, &block); end

  def external_id(*args); end

  def kind_sym(); end

  def pod_cid_rs(*args); end

  def pod_cidr(*args); end

  def provider_id(*args); end

  def serialize(); end

  def taint(elem_name=T.unsafe(nil), &block); end

  def taints(); end

  def unschedulable(*args); end
end

class KubeDSL::DSL::V1::NodeSpec
end

class KubeDSL::DSL::V1::NodeStatus
  def address(elem_name=T.unsafe(nil), &block); end

  def addresses(); end

  def allocatable(*args, &block); end

  def capacity(*args, &block); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def config(*args, &block); end

  def daemon_endpoints(*args, &block); end

  def image(elem_name=T.unsafe(nil), &block); end

  def images(); end

  def kind_sym(); end

  def node_info(*args, &block); end

  def phase(*args); end

  def serialize(); end

  def volumes_attached(elem_name=T.unsafe(nil), &block); end

  def volumes_attacheds(); end

  def volumes_in_use(*args); end
end

class KubeDSL::DSL::V1::NodeStatus
end

class KubeDSL::DSL::V1::NodeSystemInfo
  def architecture(*args); end

  def boot_id(*args); end

  def container_runtime_version(*args); end

  def kernel_version(*args); end

  def kind_sym(); end

  def kube_proxy_version(*args); end

  def kubelet_version(*args); end

  def machine_id(*args); end

  def operating_system(*args); end

  def os_image(*args); end

  def serialize(); end

  def system_uuid(*args); end
end

class KubeDSL::DSL::V1::NodeSystemInfo
end

class KubeDSL::DSL::V1::ObjectFieldSelector
  def api_version(*args); end

  def field_path(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ObjectFieldSelector
end

class KubeDSL::DSL::V1::ObjectReference
  def api_version(*args); end

  def field_path(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def resource_version(*args); end

  def serialize(); end

  def uid(*args); end
end

class KubeDSL::DSL::V1::ObjectReference
end

class KubeDSL::DSL::V1::PersistentVolume
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::PersistentVolume
end

class KubeDSL::DSL::V1::PersistentVolumeClaim
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaim
end

class KubeDSL::DSL::V1::PersistentVolumeClaimCondition
  def kind_sym(); end

  def last_probe_time(*args); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimCondition
end

class KubeDSL::DSL::V1::PersistentVolumeClaimList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimList
end

class KubeDSL::DSL::V1::PersistentVolumeClaimSpec
  def access_modes(*args); end

  def data_source(*args, &block); end

  def kind_sym(); end

  def resources(*args, &block); end

  def selector(*args, &block); end

  def serialize(); end

  def storage_class_name(*args); end

  def volume_mode(*args); end

  def volume_name(*args); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimSpec
end

class KubeDSL::DSL::V1::PersistentVolumeClaimStatus
  def access_modes(*args); end

  def capacity(*args, &block); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def kind_sym(); end

  def phase(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimStatus
end

class KubeDSL::DSL::V1::PersistentVolumeClaimVolumeSource
  def claim_name(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PersistentVolumeClaimVolumeSource
end

class KubeDSL::DSL::V1::PersistentVolumeList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PersistentVolumeList
end

class KubeDSL::DSL::V1::PersistentVolumeSpec
  def access_modes(*args); end

  def aws_elastic_block_store(*args, &block); end

  def azure_disk(*args, &block); end

  def azure_file(*args, &block); end

  def capacity(*args, &block); end

  def cephfs(*args, &block); end

  def cinder(*args, &block); end

  def claim_ref(*args, &block); end

  def csi(*args, &block); end

  def fc(*args, &block); end

  def flex_volume(*args, &block); end

  def flocker(*args, &block); end

  def gce_persistent_disk(*args, &block); end

  def glusterfs(*args, &block); end

  def host_path(*args, &block); end

  def iscsi(*args, &block); end

  def kind_sym(); end

  def local(*args, &block); end

  def mount_options(*args); end

  def nfs(*args, &block); end

  def node_affinity(*args, &block); end

  def persistent_volume_reclaim_policy(*args); end

  def photon_persistent_disk(*args, &block); end

  def portworx_volume(*args, &block); end

  def quobyte(*args, &block); end

  def rbd(*args, &block); end

  def scale_io(*args, &block); end

  def serialize(); end

  def storage_class_name(*args); end

  def storageos(*args, &block); end

  def volume_mode(*args); end

  def vsphere_volume(*args, &block); end
end

class KubeDSL::DSL::V1::PersistentVolumeSpec
end

class KubeDSL::DSL::V1::PersistentVolumeStatus
  def kind_sym(); end

  def message(*args); end

  def phase(*args); end

  def reason(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PersistentVolumeStatus
end

class KubeDSL::DSL::V1::PhotonPersistentDiskVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def pd_id(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PhotonPersistentDiskVolumeSource
end

class KubeDSL::DSL::V1::Pod
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::Pod
end

class KubeDSL::DSL::V1::PodAffinity
  def kind_sym(); end

  def preferred_during_scheduling_ignored_during_execution(elem_name=T.unsafe(nil), &block); end

  def preferred_during_scheduling_ignored_during_executions(); end

  def required_during_scheduling_ignored_during_execution(elem_name=T.unsafe(nil), &block); end

  def required_during_scheduling_ignored_during_executions(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodAffinity
end

class KubeDSL::DSL::V1::PodAffinityTerm
  def kind_sym(); end

  def label_selector(*args, &block); end

  def namespaces(*args); end

  def serialize(); end

  def topology_key(*args); end
end

class KubeDSL::DSL::V1::PodAffinityTerm
end

class KubeDSL::DSL::V1::PodAntiAffinity
  def kind_sym(); end

  def preferred_during_scheduling_ignored_during_execution(elem_name=T.unsafe(nil), &block); end

  def preferred_during_scheduling_ignored_during_executions(); end

  def required_during_scheduling_ignored_during_execution(elem_name=T.unsafe(nil), &block); end

  def required_during_scheduling_ignored_during_executions(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodAntiAffinity
end

class KubeDSL::DSL::V1::PodCondition
  def kind_sym(); end

  def last_probe_time(*args); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::PodCondition
end

class KubeDSL::DSL::V1::PodDNSConfig
  def kind_sym(); end

  def nameservers(*args); end

  def option(elem_name=T.unsafe(nil), &block); end

  def options(); end

  def searches(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodDNSConfig
end

class KubeDSL::DSL::V1::PodDNSConfigOption
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::V1::PodDNSConfigOption
end

class KubeDSL::DSL::V1::PodIP
  def ip(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodIP
end

class KubeDSL::DSL::V1::PodList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodList
end

class KubeDSL::DSL::V1::PodReadinessGate
  def condition_type(*args); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodReadinessGate
end

class KubeDSL::DSL::V1::PodSecurityContext
  def fs_group(*args); end

  def kind_sym(); end

  def run_as_group(*args); end

  def run_as_non_root(*args); end

  def run_as_user(*args); end

  def se_linux_options(*args, &block); end

  def serialize(); end

  def supplemental_groups(*args); end

  def sysctls(elem_name=T.unsafe(nil), &block); end

  def sysctlses(); end

  def windows_options(*args, &block); end
end

class KubeDSL::DSL::V1::PodSecurityContext
end

class KubeDSL::DSL::V1::PodSpec
  def active_deadline_seconds(*args); end

  def affinity(*args, &block); end

  def automount_service_account_token(*args); end

  def container(elem_name=T.unsafe(nil), &block); end

  def containers(); end

  def dns_config(*args, &block); end

  def dns_policy(*args); end

  def enable_service_links(*args); end

  def ephemeral_container(elem_name=T.unsafe(nil), &block); end

  def ephemeral_containers(); end

  def host_alias(elem_name=T.unsafe(nil), &block); end

  def host_aliases(); end

  def host_ipc(*args); end

  def host_network(*args); end

  def host_pid(*args); end

  def hostname(*args); end

  def image_pull_secret(elem_name=T.unsafe(nil), &block); end

  def image_pull_secrets(); end

  def init_container(elem_name=T.unsafe(nil), &block); end

  def init_containers(); end

  def kind_sym(); end

  def node_name(*args); end

  def node_selector(*args, &block); end

  def overhead(*args, &block); end

  def preemption_policy(*args); end

  def priority(*args); end

  def priority_class_name(*args); end

  def readiness_gate(elem_name=T.unsafe(nil), &block); end

  def readiness_gates(); end

  def restart_policy(*args); end

  def runtime_class_name(*args); end

  def scheduler_name(*args); end

  def security_context(*args, &block); end

  def serialize(); end

  def service_account(*args); end

  def service_account_name(*args); end

  def share_process_namespace(*args); end

  def subdomain(*args); end

  def termination_grace_period_seconds(*args); end

  def toleration(elem_name=T.unsafe(nil), &block); end

  def tolerations(); end

  def topology_spread_constraint(elem_name=T.unsafe(nil), &block); end

  def topology_spread_constraints(); end

  def volume(elem_name=T.unsafe(nil), &block); end

  def volumes(); end
end

class KubeDSL::DSL::V1::PodSpec
end

class KubeDSL::DSL::V1::PodStatus
  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def container_status(elem_name=T.unsafe(nil), &block); end

  def container_statuses(); end

  def ephemeral_container_status(elem_name=T.unsafe(nil), &block); end

  def ephemeral_container_statuses(); end

  def host_ip(*args); end

  def init_container_status(elem_name=T.unsafe(nil), &block); end

  def init_container_statuses(); end

  def kind_sym(); end

  def message(*args); end

  def nominated_node_name(*args); end

  def phase(*args); end

  def pod_ip(elem_name=T.unsafe(nil), &block); end

  def pod_ips(); end

  def qos_class(*args); end

  def reason(*args); end

  def serialize(); end

  def start_time(*args); end
end

class KubeDSL::DSL::V1::PodStatus
end

class KubeDSL::DSL::V1::PodTemplate
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def template(*args, &block); end
end

class KubeDSL::DSL::V1::PodTemplate
end

class KubeDSL::DSL::V1::PodTemplateList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::PodTemplateList
end

class KubeDSL::DSL::V1::PodTemplateSpec
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end
end

class KubeDSL::DSL::V1::PodTemplateSpec
end

class KubeDSL::DSL::V1::PortworxVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def serialize(); end

  def volume_id(*args); end
end

class KubeDSL::DSL::V1::PortworxVolumeSource
end

class KubeDSL::DSL::V1::PreferredSchedulingTerm
  def kind_sym(); end

  def preference(*args, &block); end

  def serialize(); end

  def weight(*args); end
end

class KubeDSL::DSL::V1::PreferredSchedulingTerm
end

class KubeDSL::DSL::V1::Probe
  def exec(*args, &block); end

  def failure_threshold(*args); end

  def http_get(*args, &block); end

  def initial_delay_seconds(*args); end

  def kind_sym(); end

  def period_seconds(*args); end

  def serialize(); end

  def success_threshold(*args); end

  def tcp_socket(*args, &block); end

  def timeout_seconds(*args); end
end

class KubeDSL::DSL::V1::Probe
end

class KubeDSL::DSL::V1::ProjectedVolumeSource
  def default_mode(*args); end

  def kind_sym(); end

  def serialize(); end

  def source(elem_name=T.unsafe(nil), &block); end

  def sources(); end
end

class KubeDSL::DSL::V1::ProjectedVolumeSource
end

class KubeDSL::DSL::V1::QuobyteVolumeSource
  def group(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def registry(*args); end

  def serialize(); end

  def tenant(*args); end

  def user(*args); end

  def volume(*args); end
end

class KubeDSL::DSL::V1::QuobyteVolumeSource
end

class KubeDSL::DSL::V1::RBDPersistentVolumeSource
  def fs_type(*args); end

  def image(*args); end

  def keyring(*args); end

  def kind_sym(); end

  def monitors(*args); end

  def pool(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def user(*args); end
end

class KubeDSL::DSL::V1::RBDPersistentVolumeSource
end

class KubeDSL::DSL::V1::RBDVolumeSource
  def fs_type(*args); end

  def image(*args); end

  def keyring(*args); end

  def kind_sym(); end

  def monitors(*args); end

  def pool(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def user(*args); end
end

class KubeDSL::DSL::V1::RBDVolumeSource
end

class KubeDSL::DSL::V1::ReplicationController
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::ReplicationController
end

class KubeDSL::DSL::V1::ReplicationControllerCondition
  def kind_sym(); end

  def last_transition_time(*args); end

  def message(*args); end

  def reason(*args); end

  def serialize(); end

  def status(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::ReplicationControllerCondition
end

class KubeDSL::DSL::V1::ReplicationControllerList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ReplicationControllerList
end

class KubeDSL::DSL::V1::ReplicationControllerSpec
  def kind_sym(); end

  def min_ready_seconds(*args); end

  def replicas(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def template(*args, &block); end
end

class KubeDSL::DSL::V1::ReplicationControllerSpec
end

class KubeDSL::DSL::V1::ReplicationControllerStatus
  def available_replicas(*args); end

  def condition(elem_name=T.unsafe(nil), &block); end

  def conditions(); end

  def fully_labeled_replicas(*args); end

  def kind_sym(); end

  def observed_generation(*args); end

  def ready_replicas(*args); end

  def replicas(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ReplicationControllerStatus
end

class KubeDSL::DSL::V1::ResourceFieldSelector
  def container_name(*args); end

  def divisor(*args); end

  def kind_sym(); end

  def resource(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ResourceFieldSelector
end

class KubeDSL::DSL::V1::ResourceQuota
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::ResourceQuota
end

class KubeDSL::DSL::V1::ResourceQuotaList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ResourceQuotaList
end

class KubeDSL::DSL::V1::ResourceQuotaSpec
  def hard(*args, &block); end

  def kind_sym(); end

  def scope_selector(*args, &block); end

  def scopes(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ResourceQuotaSpec
end

class KubeDSL::DSL::V1::ResourceQuotaStatus
  def hard(*args, &block); end

  def kind_sym(); end

  def serialize(); end

  def used(*args, &block); end
end

class KubeDSL::DSL::V1::ResourceQuotaStatus
end

class KubeDSL::DSL::V1::ResourceRequirements
  def kind_sym(); end

  def limits(*args, &block); end

  def requests(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ResourceRequirements
end

class KubeDSL::DSL::V1::SELinuxOptions
  def kind_sym(); end

  def level(*args); end

  def role(*args); end

  def serialize(); end

  def type(*args); end

  def user(*args); end
end

class KubeDSL::DSL::V1::SELinuxOptions
end

class KubeDSL::DSL::V1::ScaleIOPersistentVolumeSource
  def fs_type(*args); end

  def gateway(*args); end

  def kind_sym(); end

  def protection_domain(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def ssl_enabled(*args); end

  def storage_mode(*args); end

  def storage_pool(*args); end

  def system(*args); end

  def volume_name(*args); end
end

class KubeDSL::DSL::V1::ScaleIOPersistentVolumeSource
end

class KubeDSL::DSL::V1::ScaleIOVolumeSource
  def fs_type(*args); end

  def gateway(*args); end

  def kind_sym(); end

  def protection_domain(*args); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def ssl_enabled(*args); end

  def storage_mode(*args); end

  def storage_pool(*args); end

  def system(*args); end

  def volume_name(*args); end
end

class KubeDSL::DSL::V1::ScaleIOVolumeSource
end

class KubeDSL::DSL::V1::ScopeSelector
  def kind_sym(); end

  def match_expression(elem_name=T.unsafe(nil), &block); end

  def match_expressions(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ScopeSelector
end

class KubeDSL::DSL::V1::ScopedResourceSelectorRequirement
  def kind_sym(); end

  def operator(*args); end

  def scope_name(*args); end

  def serialize(); end

  def values(*args); end
end

class KubeDSL::DSL::V1::ScopedResourceSelectorRequirement
end

class KubeDSL::DSL::V1::Secret
  def data(*args, &block); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def string_data(*args, &block); end

  def type(*args); end
end

class KubeDSL::DSL::V1::Secret
end

class KubeDSL::DSL::V1::SecretEnvSource
  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretEnvSource
end

class KubeDSL::DSL::V1::SecretKeySelector
  def key(*args); end

  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretKeySelector
end

class KubeDSL::DSL::V1::SecretList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretList
end

class KubeDSL::DSL::V1::SecretProjection
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def name(*args); end

  def optional(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretProjection
end

class KubeDSL::DSL::V1::SecretReference
  def kind_sym(); end

  def name(*args); end

  def namespace(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretReference
end

class KubeDSL::DSL::V1::SecretVolumeSource
  def default_mode(*args); end

  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def optional(*args); end

  def secret_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SecretVolumeSource
end

class KubeDSL::DSL::V1::SecurityContext
  def allow_privilege_escalation(*args); end

  def capabilities(*args, &block); end

  def kind_sym(); end

  def privileged(*args); end

  def proc_mount(*args); end

  def read_only_root_filesystem(*args); end

  def run_as_group(*args); end

  def run_as_non_root(*args); end

  def run_as_user(*args); end

  def se_linux_options(*args, &block); end

  def serialize(); end

  def windows_options(*args, &block); end
end

class KubeDSL::DSL::V1::SecurityContext
end

class KubeDSL::DSL::V1::Service
  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end

  def spec(*args, &block); end

  def status(*args, &block); end
end

class KubeDSL::DSL::V1::Service
end

class KubeDSL::DSL::V1::ServiceAccount
  def automount_service_account_token(*args); end

  def image_pull_secret(elem_name=T.unsafe(nil), &block); end

  def image_pull_secrets(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def secret(elem_name=T.unsafe(nil), &block); end

  def secrets(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ServiceAccount
end

class KubeDSL::DSL::V1::ServiceAccountList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ServiceAccountList
end

class KubeDSL::DSL::V1::ServiceAccountTokenProjection
  def audience(*args); end

  def expiration_seconds(*args); end

  def kind_sym(); end

  def path(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ServiceAccountTokenProjection
end

class KubeDSL::DSL::V1::ServiceList
  def item(elem_name=T.unsafe(nil), &block); end

  def items(); end

  def kind_sym(); end

  def metadata(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ServiceList
end

class KubeDSL::DSL::V1::ServicePort
  def kind_sym(); end

  def name(*args); end

  def node_port(*args); end

  def port(*args); end

  def protocol(*args); end

  def serialize(); end

  def target_port(*args); end
end

class KubeDSL::DSL::V1::ServicePort
end

class KubeDSL::DSL::V1::ServiceSpec
  def cluster_ip(*args); end

  def external_i_ps(*args); end

  def external_name(*args); end

  def external_traffic_policy(*args); end

  def health_check_node_port(*args); end

  def ip_family(*args); end

  def kind_sym(); end

  def load_balancer_ip(*args); end

  def load_balancer_source_ranges(*args); end

  def port(elem_name=T.unsafe(nil), &block); end

  def ports(); end

  def publish_not_ready_addresses(*args); end

  def selector(*args, &block); end

  def serialize(); end

  def session_affinity(*args); end

  def session_affinity_config(*args, &block); end

  def topology_keys(*args); end

  def type(*args); end
end

class KubeDSL::DSL::V1::ServiceSpec
end

class KubeDSL::DSL::V1::ServiceStatus
  def kind_sym(); end

  def load_balancer(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::ServiceStatus
end

class KubeDSL::DSL::V1::SessionAffinityConfig
  def client_ip(*args, &block); end

  def kind_sym(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::SessionAffinityConfig
end

class KubeDSL::DSL::V1::StorageOSPersistentVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def volume_name(*args); end

  def volume_namespace(*args); end
end

class KubeDSL::DSL::V1::StorageOSPersistentVolumeSource
end

class KubeDSL::DSL::V1::StorageOSVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def read_only(*args); end

  def secret_ref(*args, &block); end

  def serialize(); end

  def volume_name(*args); end

  def volume_namespace(*args); end
end

class KubeDSL::DSL::V1::StorageOSVolumeSource
end

class KubeDSL::DSL::V1::Sysctl
  def kind_sym(); end

  def name(*args); end

  def serialize(); end

  def value(*args); end
end

class KubeDSL::DSL::V1::Sysctl
end

class KubeDSL::DSL::V1::TCPSocketAction
  def host(*args); end

  def kind_sym(); end

  def port(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::TCPSocketAction
end

class KubeDSL::DSL::V1::Taint
  def effect(*args); end

  def key(*args); end

  def kind_sym(); end

  def serialize(); end

  def time_added(*args); end

  def value(*args); end
end

class KubeDSL::DSL::V1::Taint
end

class KubeDSL::DSL::V1::Toleration
  def effect(*args); end

  def key(*args); end

  def kind_sym(); end

  def operator(*args); end

  def serialize(); end

  def toleration_seconds(*args); end

  def value(*args); end
end

class KubeDSL::DSL::V1::Toleration
end

class KubeDSL::DSL::V1::TopologySelectorLabelRequirement
  def key(*args); end

  def kind_sym(); end

  def serialize(); end

  def values(*args); end
end

class KubeDSL::DSL::V1::TopologySelectorLabelRequirement
end

class KubeDSL::DSL::V1::TopologySelectorTerm
  def kind_sym(); end

  def match_label_expression(elem_name=T.unsafe(nil), &block); end

  def match_label_expressions(); end

  def serialize(); end
end

class KubeDSL::DSL::V1::TopologySelectorTerm
end

class KubeDSL::DSL::V1::TopologySpreadConstraint
  def kind_sym(); end

  def label_selector(*args, &block); end

  def max_skew(*args); end

  def serialize(); end

  def topology_key(*args); end

  def when_unsatisfiable(*args); end
end

class KubeDSL::DSL::V1::TopologySpreadConstraint
end

class KubeDSL::DSL::V1::TypedLocalObjectReference
  def api_group(*args); end

  def kind(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::TypedLocalObjectReference
end

class KubeDSL::DSL::V1::Volume
  def aws_elastic_block_store(*args, &block); end

  def azure_disk(*args, &block); end

  def azure_file(*args, &block); end

  def cephfs(*args, &block); end

  def cinder(*args, &block); end

  def config_map(*args, &block); end

  def csi(*args, &block); end

  def downward_api(*args, &block); end

  def empty_dir(*args, &block); end

  def fc(*args, &block); end

  def flex_volume(*args, &block); end

  def flocker(*args, &block); end

  def gce_persistent_disk(*args, &block); end

  def git_repo(*args, &block); end

  def glusterfs(*args, &block); end

  def host_path(*args, &block); end

  def iscsi(*args, &block); end

  def kind_sym(); end

  def name(*args); end

  def nfs(*args, &block); end

  def persistent_volume_claim(*args, &block); end

  def photon_persistent_disk(*args, &block); end

  def portworx_volume(*args, &block); end

  def projected(*args, &block); end

  def quobyte(*args, &block); end

  def rbd(*args, &block); end

  def scale_io(*args, &block); end

  def secret(*args, &block); end

  def serialize(); end

  def storageos(*args, &block); end

  def vsphere_volume(*args, &block); end
end

class KubeDSL::DSL::V1::Volume
end

class KubeDSL::DSL::V1::VolumeDevice
  def device_path(*args); end

  def kind_sym(); end

  def name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::VolumeDevice
end

class KubeDSL::DSL::V1::VolumeMount
  def kind_sym(); end

  def mount_path(*args); end

  def mount_propagation(*args); end

  def name(*args); end

  def read_only(*args); end

  def serialize(); end

  def sub_path(*args); end

  def sub_path_expr(*args); end
end

class KubeDSL::DSL::V1::VolumeMount
end

class KubeDSL::DSL::V1::VolumeNodeAffinity
  def kind_sym(); end

  def required(*args, &block); end

  def serialize(); end
end

class KubeDSL::DSL::V1::VolumeNodeAffinity
end

class KubeDSL::DSL::V1::VolumeProjection
  def config_map(*args, &block); end

  def downward_api(*args, &block); end

  def kind_sym(); end

  def secret(*args, &block); end

  def serialize(); end

  def service_account_token(*args, &block); end
end

class KubeDSL::DSL::V1::VolumeProjection
end

class KubeDSL::DSL::V1::VsphereVirtualDiskVolumeSource
  def fs_type(*args); end

  def kind_sym(); end

  def serialize(); end

  def storage_policy_id(*args); end

  def storage_policy_name(*args); end

  def volume_path(*args); end
end

class KubeDSL::DSL::V1::VsphereVirtualDiskVolumeSource
end

class KubeDSL::DSL::V1::WeightedPodAffinityTerm
  def kind_sym(); end

  def pod_affinity_term(*args, &block); end

  def serialize(); end

  def weight(*args); end
end

class KubeDSL::DSL::V1::WeightedPodAffinityTerm
end

class KubeDSL::DSL::V1::WindowsSecurityContextOptions
  def gmsa_credential_spec(*args); end

  def gmsa_credential_spec_name(*args); end

  def kind_sym(); end

  def run_as_user_name(*args); end

  def serialize(); end
end

class KubeDSL::DSL::V1::WindowsSecurityContextOptions
end

module KubeDSL::DSL::V1
end

class KubeDSL::DSLObject
  include ::KubeDSL::ValueFields::InstanceMethods
  include ::KubeDSL::Validations::InstanceMethods
  def initialize(&block); end
end

class KubeDSL::DSLObject
  extend ::KubeDSL::ValueFields
  extend ::KubeDSL::ValueFields::ClassMethods
  extend ::KubeDSL::Validations
  extend ::KubeDSL::Validations::ClassMethods
end

class KubeDSL::DefaultFieldRes
  include ::KubeDSL::StringHelpers
  def allowed_values(); end

  def fields_to_ruby(_inflector); end

  def initialize(name, res, allowed_values); end

  def name(); end

  def res(); end

  def serialize_call(_inflector); end

  def validations(_inflector); end
end

class KubeDSL::DefaultFieldRes
end

class KubeDSL::ExternalRef
end

class KubeDSL::ExternalRef
end

class KubeDSL::ExternalResourceMeta
  def external?(); end

  def initialize(ref); end

  def ref(); end
end

class KubeDSL::ExternalResourceMeta
end

class KubeDSL::FieldRes
  include ::KubeDSL::StringHelpers
  def fields_to_ruby(_inflector); end

  def initialize(name, type, required); end

  def name(); end

  def required(); end

  def required?(); end

  def serialize_call(_inflector); end

  def type(); end

  def validations(_inflector); end
end

class KubeDSL::FieldRes
end

class KubeDSL::Generator
  def builder(); end

  def generate(); end

  def generate_autoload_files(); end

  def generate_entrypoint_file(&block); end

  def generate_resource_files(); end

  def initialize(*args, **kwargs); end
end

class KubeDSL::Generator
end

class KubeDSL::Inflector
  include ::Singleton
  def inflector(); end
end

class KubeDSL::Inflector
  extend ::Singleton::SingletonClassMethods
  def self.pluralize(*args); end

  def self.singularize(*args); end
end

class KubeDSL::KeyValueFieldRes
  include ::KubeDSL::StringHelpers
  def fields_to_ruby(_inflector); end

  def initialize(name, res, type, required); end

  def name(); end

  def required(); end

  def required?(); end

  def res(); end

  def serialize_call(_inflector); end

  def type(); end

  def validations(_inflector); end
end

class KubeDSL::KeyValueFieldRes
end

class KubeDSL::KeyValueFields
  def add(key, value); end

  def format(); end

  def get(key); end

  def initialize(format: T.unsafe(nil)); end

  def kv_pairs(); end

  def merge!(other); end

  def remove(key); end

  def serialize(); end

  def set(key, value); end
end

class KubeDSL::KeyValueFields
end

class KubeDSL::ObjectFieldRes
  include ::KubeDSL::StringHelpers
  def fields_to_ruby(_inflector); end

  def initialize(name, res); end

  def name(); end

  def res(); end

  def serialize_call(_inflector); end

  def validations(_inflector); end
end

class KubeDSL::ObjectFieldRes
end

class KubeDSL::Ref
  include ::KubeDSL::StringHelpers
  def autoload_prefix(); end

  def document(); end

  def inflector(); end

  def initialize(str, ruby_namespace_prefix, inflector, schema_dir, autoload_prefix); end

  def kind(); end

  def meta(); end

  def namespace(); end

  def object?(); end

  def ruby_autoload_path(); end

  def ruby_namespace(); end

  def ruby_namespace_prefix(); end

  def schema_dir(); end

  def str(); end

  def version(); end
end

class KubeDSL::Ref
end

class KubeDSL::Resource
  def contents(); end

  def initialize(contents); end

  def serialize(); end

  def to_resource(); end
end

class KubeDSL::ResourceMeta
  include ::KubeDSL::StringHelpers
  def empty?(); end

  def external?(); end

  def fields(); end

  def inflector(); end

  def initialize(ref, inflector); end

  def ref(); end

  def to_ruby(); end
end

class KubeDSL::ResourceMeta
end

module KubeDSL::StringHelpers
  def capitalize(str); end

  def underscore(str); end

  def unkeywordify(str); end
  RUBY_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module KubeDSL::StringHelpers
  extend ::KubeDSL::StringHelpers
end

module KubeDSL::Validations
end

class KubeDSL::Validations::ArrayValidator
  def field_name(); end

  def initialize(field_name, opts); end

  def kind_of(); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::ArrayValidator
end

module KubeDSL::Validations::ClassMethods
  def validates(field_name, options); end

  def validators(); end
end

module KubeDSL::Validations::ClassMethods
end

class KubeDSL::Validations::FieldValidator
  def field_name(); end

  def format_validator(); end

  def initialize(field_name, options=T.unsafe(nil)); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::FieldValidator
end

class KubeDSL::Validations::FormatValidator
  def format(); end

  def initialize(format); end

  def klasses(); end

  def valid?(obj); end
end

class KubeDSL::Validations::FormatValidator
end

class KubeDSL::Validations::InclusionValidator
  def field_name(); end

  def initialize(field_name, opts); end

  def list(); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::InclusionValidator
end

module KubeDSL::Validations::InstanceMethods
  def valid?(); end

  def validate(errors=T.unsafe(nil), nesting=T.unsafe(nil)); end

  def validate!(); end
end

module KubeDSL::Validations::InstanceMethods
end

class KubeDSL::Validations::KeyValueValidator
  def field_name(); end

  def format_validator(); end

  def initialize(field_name, options=T.unsafe(nil)); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::KeyValueValidator
end

class KubeDSL::Validations::ObjectValidator
  def field_name(); end

  def initialize(field_name, opts); end

  def kind_of(); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::ObjectValidator
end

class KubeDSL::Validations::PresenceValidator
  def field_name(); end

  def initialize(field_name, presence); end

  def presence(); end

  def validate(obj, errors, nesting); end
end

class KubeDSL::Validations::PresenceValidator
end

class KubeDSL::Validations::ValidationErrors
  def add(field_name, msg); end

  def empty?(); end

  def messages(); end
end

class KubeDSL::Validations::ValidationErrors
end

module KubeDSL::Validations
  def self.extended(base); end
end

module KubeDSL::ValueFields
end

module KubeDSL::ValueFields::ClassMethods
  def __fields__(); end

  def array_field(field, accessor=T.unsafe(nil), &field_block); end

  def key_value_field(field, format:); end

  def object_field(field, &field_block); end

  def value_field(field, default: T.unsafe(nil)); end

  def value_fields(*fields); end
end

module KubeDSL::ValueFields::ClassMethods
end

class KubeDSL::ValueFields::ClassMismatchError
end

class KubeDSL::ValueFields::ClassMismatchError
end

module KubeDSL::ValueFields::InstanceMethods
  def merge(other, fields); end

  def merge!(other, fields: T.unsafe(nil)); end
end

module KubeDSL::ValueFields::InstanceMethods
end

module KubeDSL::ValueFields
  def self.extended(base); end
end

class KubernetesCLI
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::DidYouMean::Correctable
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::Byebug::Breakpoints::FileBreakpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class RDoc::Alias
  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end
end

class RDoc::Attr
  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end
end

class RDoc::ClassModule
  def initialize(name, superclass=T.unsafe(nil)); end
end

class RDoc::CodeObject
  def initialize_visibility(); end
end

class RDoc::Comment
  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end
end

class RDoc::Constant
  def initialize(name, value, comment); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context
  def add_module_by_normal_module(mod); end

  def initialize_methods_etc(); end
end

class RDoc::Context::Section
  def initialize(parent, title, comment); end
end

class RDoc::CrossReference
  def initialize(context); end
end

class RDoc::ERBIO
  def initialize(str, safe_level=T.unsafe(nil), trim_mode=T.unsafe(nil), eoutvar=T.unsafe(nil)); end
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.detect_encoding(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Generator::Darkfish
  def initialize(store, options); end
end

class RDoc::Generator::JsonIndex
  def initialize(parent_generator, options); end
end

class RDoc::Generator::POT
  def initialize(store, options); end
end

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options=T.unsafe(nil)); end
end

class RDoc::Generator::RI
  def initialize(store, options); end
end

class RDoc::I18n::Locale
  def initialize(name); end
end

class RDoc::I18n::Text
  def initialize(raw); end
end

class RDoc::Markdown
  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals
  def initialize(str, debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markup
  def add_regexp_handling(pattern, name); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrSpan
  def initialize(length); end
end

class RDoc::Markup::AttributeManager
  def add_regexp_handling(pattern, name); end

  def convert_regexp_handlings(str, attrs); end

  def regexp_handlings(); end
end

class RDoc::Markup::Attributes
  def regexp_handling(); end
end

class RDoc::Markup::Document
  def initialize(*parts); end
end

class RDoc::Markup::Formatter
  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def convert_regexp_handling(target); end

  def initialize(options, markup=T.unsafe(nil)); end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end
end

class RDoc::Markup::IndentedParagraph
  def initialize(indent, *parts); end
end

class RDoc::Markup::List
  def initialize(type=T.unsafe(nil), *items); end
end

class RDoc::Markup::ListItem
  def initialize(label=T.unsafe(nil), *parts); end
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end
end

class RDoc::Markup::Raw
  def initialize(*parts); end
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::ToHtml
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToHtmlCrossref
  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToHtmlSnippet
  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToJoinedParagraph
  def initialize(); end
end

class RDoc::Markup::ToLabel
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToMarkdown
  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToRdoc
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToTableOfContents
  def initialize(); end
end

class RDoc::Markup::ToTtOnly
  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::MethodAttr
  def initialize(text, name); end
end

class RDoc::Mixin
  def initialize(name, comment); end
end

class RDoc::Parser
  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  def do_classes_and_modules(); end
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  def get_included_module_with_optional_parens(); end

  def retrieve_comment_body(tk); end
end

module RDoc::Parser::RubyTools
  def skip_tkspace_without_nl(); end
end

class RDoc::RD::BlockParser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::Inline
  def initialize(rdoc, reference); end
end

class RDoc::RD::InlineParser
  def initialize(block_parser); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RI::Driver
  def initialize(initial_options=T.unsafe(nil)); end
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end
end

RDoc::RI::Store = RDoc::Store

class RDoc::Require
  def initialize(name, comment); end
end

class RDoc::Servlet
  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end
end

class RDoc::Stats
  def initialize(store, num_files, verbosity=T.unsafe(nil)); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end
end

class RDoc::Store
  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::MissingFileError
  def initialize(store, file, name); end
end

class RDoc::Task
  def before_running_rdoc(&block); end

  def check_names(names); end

  def clobber_task_description(); end

  def defaults(); end

  def define(); end

  def external(); end

  def external=(external); end

  def generator(); end

  def generator=(generator); end

  def initialize(name=T.unsafe(nil)); end

  def inline_source(); end

  def inline_source=(value); end

  def main(); end

  def main=(main); end

  def markup(); end

  def markup=(markup); end

  def name(); end

  def name=(name); end

  def option_list(); end

  def options(); end

  def options=(options); end

  def rdoc_dir(); end

  def rdoc_dir=(rdoc_dir); end

  def rdoc_files(); end

  def rdoc_files=(rdoc_files); end

  def rdoc_task_description(); end

  def rerdoc_task_description(); end

  def template(); end

  def template=(template); end

  def title(); end

  def title=(title); end
end

class RDoc::Task
end

module RDoc::Text
  def language(); end

  def language=(language); end
end

class RDoc::TopLevel
  def initialize(absolute_name, relative_name=T.unsafe(nil)); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  def run_exec(*expected, &block_arg); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

Rake::RDocTask = RDoc::Task

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

module Reline
  def eof?(*args, &block); end
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(x); end

  def self.move_cursor_down(x); end

  def self.move_cursor_up(x); end

  def self.output=(val); end

  def self.prep(); end

  def self.retrieve_keybuffer(); end

  def self.scroll_down(x); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::Config
  def add_default_key_binding(keystroke, target); end

  def bind_key(key, func_name); end

  def bind_tty_special_chars(); end

  def bind_tty_special_chars=(bind_tty_special_chars); end

  def bind_variable(name, value); end

  def blink_matching_paren(); end

  def blink_matching_paren=(blink_matching_paren); end

  def byte_oriented(); end

  def byte_oriented=(byte_oriented); end

  def completion_ignore_case(); end

  def completion_ignore_case=(completion_ignore_case); end

  def convert_meta(); end

  def convert_meta=(convert_meta); end

  def disable_completion(); end

  def disable_completion=(disable_completion); end

  def editing_mode(); end

  def editing_mode=(val); end

  def editing_mode_is?(*val); end

  def emacs_mode_string(); end

  def emacs_mode_string=(emacs_mode_string); end

  def enable_keypad(); end

  def enable_keypad=(enable_keypad); end

  def expand_tilde(); end

  def expand_tilde=(expand_tilde); end

  def handle_directive(directive, file, no); end

  def history_preserve_point(); end

  def history_preserve_point=(history_preserve_point); end

  def history_size(); end

  def history_size=(history_size); end

  def horizontal_scroll_mode(); end

  def horizontal_scroll_mode=(horizontal_scroll_mode); end

  def input_meta(); end

  def input_meta=(input_meta); end

  def inputrc_path(); end

  def key_bindings(); end

  def key_notation_to_code(notation); end

  def keymap(); end

  def keyseq_timeout(); end

  def keyseq_timeout=(keyseq_timeout); end

  def mark_directories(); end

  def mark_directories=(mark_directories); end

  def mark_modified_lines(); end

  def mark_modified_lines=(mark_modified_lines); end

  def mark_symlinked_directories(); end

  def mark_symlinked_directories=(mark_symlinked_directories); end

  def match_hidden_files(); end

  def match_hidden_files=(match_hidden_files); end

  def meta_flag(); end

  def meta_flag=(meta_flag); end

  def output_meta(); end

  def output_meta=(output_meta); end

  def page_completions(); end

  def page_completions=(page_completions); end

  def parse_keyseq(str); end

  def prefer_visible_bell(); end

  def prefer_visible_bell=(prefer_visible_bell); end

  def print_completions_horizontally(); end

  def print_completions_horizontally=(print_completions_horizontally); end

  def read(file=T.unsafe(nil)); end

  def read_lines(lines, file=T.unsafe(nil)); end

  def reset(); end

  def reset_default_key_bindings(); end

  def retrieve_string(str); end

  def show_all_if_ambiguous(); end

  def show_all_if_ambiguous=(show_all_if_ambiguous); end

  def show_all_if_unmodified(); end

  def show_all_if_unmodified=(show_all_if_unmodified); end

  def show_mode_in_prompt(); end

  def show_mode_in_prompt=(show_mode_in_prompt); end

  def test_mode(); end

  def vi_cmd_mode_icon(); end

  def vi_cmd_mode_icon=(vi_cmd_mode_icon); end

  def vi_ins_mode_icon(); end

  def vi_ins_mode_icon=(vi_ins_mode_icon); end

  def visible_stats(); end

  def visible_stats=(visible_stats); end
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Config::InvalidInputrc
  def file(); end

  def file=(file); end

  def lineno(); end

  def lineno=(lineno); end
end

class Reline::Config::InvalidInputrc
end

class Reline::Config
end

class Reline::Core
  def ambiguous_width(); end

  def ambiguous_width=(ambiguous_width); end

  def auto_indent_proc(); end

  def auto_indent_proc=(p); end

  def basic_quote_characters(); end

  def basic_quote_characters=(v); end

  def basic_word_break_characters(); end

  def basic_word_break_characters=(v); end

  def completer_quote_characters(); end

  def completer_quote_characters=(v); end

  def completer_word_break_characters(); end

  def completer_word_break_characters=(v); end

  def completion_append_character(); end

  def completion_append_character=(val); end

  def completion_case_fold(); end

  def completion_case_fold=(v); end

  def completion_proc(); end

  def completion_proc=(p); end

  def completion_quote_character(); end

  def config(); end

  def config=(config); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(p); end

  def emacs_editing_mode(); end

  def emacs_editing_mode?(); end

  def encoding(); end

  def filename_quote_characters(); end

  def filename_quote_characters=(v); end

  def get_screen_size(); end

  def input=(val); end

  def key_stroke(); end

  def key_stroke=(key_stroke); end

  def last_incremental_search(); end

  def last_incremental_search=(last_incremental_search); end

  def line_editor(); end

  def line_editor=(line_editor); end

  def output(); end

  def output=(val); end

  def output_modifier_proc(); end

  def output_modifier_proc=(p); end

  def pre_input_hook(); end

  def pre_input_hook=(p); end

  def prompt_proc(); end

  def prompt_proc=(p); end

  def readline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil)); end

  def readmultiline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil), &confirm_multiline_termination); end

  def special_prefixes(); end

  def special_prefixes=(v); end

  def vi_editing_mode(); end

  def vi_editing_mode?(); end
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Core
end

class Reline::CursorPos
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Reline::CursorPos
  def self.[](*_); end

  def self.members(); end
end

class Reline::GeneralIO
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::GeneralIO
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(val); end

  def self.move_cursor_down(val); end

  def self.move_cursor_up(val); end

  def self.prep(); end

  def self.scroll_down(val); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::History
  def <<(val); end

  def [](index); end

  def []=(index, val); end

  def concat(*val); end

  def delete_at(index); end

  def initialize(config); end

  def push(*val); end
end

class Reline::History
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

module Reline::KeyActor
end

class Reline::KeyActor::Base
  def get_method(key); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Base
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
end

module Reline::KeyActor
end

class Reline::KeyStroke
  def expand(input); end

  def initialize(config); end

  def match_status(input); end
end

class Reline::KeyStroke
end

class Reline::KillRing
  def append(string, before_p=T.unsafe(nil)); end

  def initialize(max=T.unsafe(nil)); end

  def process(); end

  def yank(); end

  def yank_pop(); end
end

class Reline::KillRing::RingBuffer
  def <<(point); end

  def empty?(); end

  def head(); end

  def initialize(max=T.unsafe(nil)); end

  def size(); end
end

class Reline::KillRing::RingBuffer
end

class Reline::KillRing::RingPoint
  def ==(other); end

  def backward(); end

  def backward=(_); end

  def forward(); end

  def forward=(_); end

  def initialize(str); end

  def str(); end

  def str=(_); end
end

class Reline::KillRing::RingPoint
  def self.[](*_); end

  def self.members(); end
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
end

class Reline::KillRing
end

class Reline::LineEditor
  def auto_indent_proc(); end

  def auto_indent_proc=(auto_indent_proc); end

  def byte_pointer(); end

  def byte_pointer=(val); end

  def call_completion_proc(); end

  def completion_append_character(); end

  def completion_append_character=(completion_append_character); end

  def completion_proc(); end

  def completion_proc=(completion_proc); end

  def confirm_multiline_termination(); end

  def confirm_multiline_termination_proc(); end

  def confirm_multiline_termination_proc=(confirm_multiline_termination_proc); end

  def delete_text(start=T.unsafe(nil), length=T.unsafe(nil)); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(dig_perfect_match_proc); end

  def editing_mode(); end

  def eof?(); end

  def finalize(); end

  def finish(); end

  def finished?(); end

  def initialize(config, encoding); end

  def input_key(key); end

  def insert_text(text); end

  def line(); end

  def multiline_off(); end

  def multiline_on(); end

  def output=(output); end

  def output_modifier_proc(); end

  def output_modifier_proc=(output_modifier_proc); end

  def pre_input_hook(); end

  def pre_input_hook=(pre_input_hook); end

  def prompt_proc(); end

  def prompt_proc=(prompt_proc); end

  def rerender(); end

  def reset(prompt=T.unsafe(nil), encoding:); end

  def reset_line(); end

  def reset_variables(prompt=T.unsafe(nil), encoding:); end

  def retrieve_completion_block(set_completion_quote_character=T.unsafe(nil)); end

  def whole_buffer(); end

  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

class Reline::LineEditor
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
end

class Reline::Unicode
  def self.calculate_width(str, allow_escape_code=T.unsafe(nil)); end

  def self.ed_transpose_words(line, byte_pointer); end

  def self.em_backward_word(line, byte_pointer); end

  def self.em_big_backward_word(line, byte_pointer); end

  def self.em_forward_word(line, byte_pointer); end

  def self.em_forward_word_with_capitalization(line, byte_pointer); end

  def self.escape_for_print(str); end

  def self.get_mbchar_byte_size_by_first_char(c); end

  def self.get_mbchar_width(mbchar); end

  def self.get_next_mbchar_size(line, byte_pointer); end

  def self.get_prev_mbchar_size(line, byte_pointer); end

  def self.split_by_width(str, max_width, encoding=T.unsafe(nil)); end

  def self.vi_backward_word(line, byte_pointer); end

  def self.vi_big_backward_word(line, byte_pointer); end

  def self.vi_big_forward_end_word(line, byte_pointer); end

  def self.vi_big_forward_word(line, byte_pointer); end

  def self.vi_first_print(line); end

  def self.vi_forward_end_word(line, byte_pointer); end

  def self.vi_forward_word(line, byte_pointer); end
end

module Reline
  extend ::Forwardable
  extend ::SingleForwardable
  def self.ambiguous_width(*args, &block); end

  def self.auto_indent_proc(*args, &block); end

  def self.auto_indent_proc=(*args, &block); end

  def self.basic_quote_characters(*args, &block); end

  def self.basic_quote_characters=(*args, &block); end

  def self.basic_word_break_characters(*args, &block); end

  def self.basic_word_break_characters=(*args, &block); end

  def self.completer_quote_characters(*args, &block); end

  def self.completer_quote_characters=(*args, &block); end

  def self.completer_word_break_characters(*args, &block); end

  def self.completer_word_break_characters=(*args, &block); end

  def self.completion_append_character(*args, &block); end

  def self.completion_append_character=(*args, &block); end

  def self.completion_case_fold(*args, &block); end

  def self.completion_case_fold=(*args, &block); end

  def self.completion_proc(*args, &block); end

  def self.completion_proc=(*args, &block); end

  def self.completion_quote_character(*args, &block); end

  def self.core(); end

  def self.delete_text(*args, &block); end

  def self.dig_perfect_match_proc(*args, &block); end

  def self.dig_perfect_match_proc=(*args, &block); end

  def self.emacs_editing_mode(*args, &block); end

  def self.emacs_editing_mode?(*args, &block); end

  def self.encoding_system_needs(); end

  def self.eof?(*args, &block); end

  def self.filename_quote_characters(*args, &block); end

  def self.filename_quote_characters=(*args, &block); end

  def self.get_screen_size(*args, &block); end

  def self.input=(*args, &block); end

  def self.insert_text(*args, &block); end

  def self.last_incremental_search(*args, &block); end

  def self.last_incremental_search=(*args, &block); end

  def self.line_buffer(*args, &block); end

  def self.line_editor(); end

  def self.output=(*args, &block); end

  def self.output_modifier_proc(*args, &block); end

  def self.output_modifier_proc=(*args, &block); end

  def self.point(*args, &block); end

  def self.point=(*args, &block); end

  def self.pre_input_hook(*args, &block); end

  def self.pre_input_hook=(*args, &block); end

  def self.prompt_proc(*args, &block); end

  def self.prompt_proc=(*args, &block); end

  def self.readline(*args, &block); end

  def self.readmultiline(*args, &block); end

  def self.redisplay(*args, &block); end

  def self.special_prefixes(*args, &block); end

  def self.special_prefixes=(*args, &block); end

  def self.vi_editing_mode(*args, &block); end

  def self.vi_editing_mode?(*args, &block); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(); end

  def scan(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(_); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex_state_name(_); end

  def self.token_match(src, pattern); end
end

class RubyLex
  def check_code_block(code); end

  def check_corresponding_token_depth(); end

  def check_newline_depth_difference(); end

  def check_state(code); end

  def check_string_literal(); end

  def each_top_level_statement(); end

  def initialize_input(); end

  def lex(); end

  def process_continue(); end

  def process_literal_type(); end

  def process_nesting_level(); end

  def prompt(); end

  def ripper_lex_without_warning(code); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
  def self.compile_with_errors_suppressed(code); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(_); end

  def filter(*_); end
end

class Struct::CompletionJourneyData
  def list(); end

  def list=(_); end

  def pointer(); end

  def pointer=(_); end

  def postposing(); end

  def postposing=(_); end

  def preposing(); end

  def preposing=(_); end
end

class Struct::CompletionJourneyData
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::Key
  def char(); end

  def char=(_); end

  def combined_char(); end

  def combined_char=(_); end

  def with_meta(); end

  def with_meta=(_); end
end

class Struct::Key
  def self.[](*_); end

  def self.members(); end
end

class Struct::MenuInfo
  def list(); end

  def list=(_); end

  def target(); end

  def target=(_); end
end

class Struct::MenuInfo
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

